"use strict";

exports.__esModule = true;
exports.default = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _hook = _interopRequireDefault(require("uncontrollable/hook"));

var _Button = _interopRequireDefault(require("./Button"));

var _Calendar = _interopRequireDefault(require("./Calendar"));

var _DateTimePickerInput = _interopRequireDefault(require("./DateTimePickerInput"));

var _Icon = require("./Icon");

var _LocalizationProvider = _interopRequireDefault(require("./LocalizationProvider"));

var _Popup = _interopRequireDefault(require("./Popup"));

var _Select = _interopRequireDefault(require("./Select"));

var _TimeInput = _interopRequireDefault(require("./TimeInput"));

var _Widget = _interopRequireDefault(require("./Widget"));

var _WidgetPicker = _interopRequireDefault(require("./WidgetPicker"));

var CustomPropTypes = _interopRequireWildcard(require("./util/PropTypes"));

var _dates = _interopRequireDefault(require("./util/dates"));

var _hooks = require("./util/hooks");

var _interaction = require("./util/interaction");

var _tabTrap = _interopRequireDefault(require("./util/tabTrap"));

var _useFocusManager2 = _interopRequireDefault(require("./util/useFocusManager"));

var _widgetHelpers = require("./util/widgetHelpers");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// import TimeList from './TimeList'
var propTypes = {
  /**
   * @example ['valuePicker', [ ['new Date()', null] ]]
   */
  value: _propTypes.default.instanceOf(Date),

  /**
   * @example ['onChangePicker', [ ['new Date()', null] ]]
   */
  onChange: _propTypes.default.func,

  /**
   * @example ['openDateTime']
   */
  open: _propTypes.default.bool,
  onToggle: _propTypes.default.func,

  /**
   * Default current date at which the calendar opens. If none is provided, opens at today's date or the `value` date (if any).
   */
  currentDate: _propTypes.default.instanceOf(Date),

  /**
   * Change event Handler that is called when the currentDate is changed. The handler is called with the currentDate object.
   */
  onCurrentDateChange: _propTypes.default.func,
  onSelect: _propTypes.default.func,

  /**
   * The minimum Date that can be selected. Min only limits selection, it doesn't constrain the date values that
   * can be typed or pasted into the widget. If you need this behavior you can constrain values via
   * the `onChange` handler.
   *
   * @example ['prop', ['min', 'new Date()']]
   */
  min: _propTypes.default.instanceOf(Date),

  /**
   * The maximum Date that can be selected. Max only limits selection, it doesn't constrain the date values that
   * can be typed or pasted into the widget. If you need this behavior you can constrain values via
   * the `onChange` handler.
   *
   * @example ['prop', ['max', 'new Date()']]
   */
  max: _propTypes.default.instanceOf(Date),

  /**
   * The amount of minutes between each entry in the time list.
   *
   * @example ['prop', { step: 90 }]
   */
  step: _propTypes.default.number,
  formats: _propTypes.default.shape({
    /**
     * A formatter used to display the date value. For more information about formats
     * visit the [Localization page](/localization)
     *
     * @example ['dateFormat', ['default', "{ raw: 'MMM dd, yyyy' }", null, { defaultValue: 'new Date()', time: 'false' }]]
     */
    value: CustomPropTypes.dateFormat,

    /**
     * A formatter to be used while the date input has focus. Useful for showing a simpler format for inputing.
     * For more information about formats visit the [Localization page](/localization)
     *
     * @example ['dateFormat', ['edit', "{ date: 'short' }", null, { defaultValue: 'new Date()', format: "{ raw: 'MMM dd, yyyy' }", time: 'false' }]]
     */
    editValue: CustomPropTypes.dateFormat
  }),

  /**
   * Enable the time list component of the picker.
   */
  includeTime: _propTypes.default.bool,
  timePrecision: _propTypes.default.oneOf(['minutes', 'seconds', 'milliseconds']),
  timeInputProps: _propTypes.default.object,

  /** Specify the element used to render the calendar dropdown icon. */
  selectIcon: _propTypes.default.node,
  dropUp: _propTypes.default.bool,
  popupTransition: CustomPropTypes.elementType,
  placeholder: _propTypes.default.string,
  name: _propTypes.default.string,
  autoFocus: _propTypes.default.bool,

  /**
   * @example ['disabled', ['new Date()']]
   */
  disabled: CustomPropTypes.disabled,

  /**
   * @example ['readOnly', ['new Date()']]
   */
  readOnly: CustomPropTypes.disabled,

  /**
   * Determines how the widget parses the typed date string into a Date object. You can provide an array of formats to try,
   * or provide a function that returns a date to handle parsing yourself. When `parse` is unspecified and
   * the `format` prop is a `string` parse will automatically use that format as its default.
   */
  parse: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.string), _propTypes.default.string, _propTypes.default.func]),

  /** @ignore */
  tabIndex: _propTypes.default.any,

  /** @ignore */
  'aria-labelledby': _propTypes.default.string,

  /** @ignore */
  'aria-describedby': _propTypes.default.string,

  /** @ignore */
  localizer: _propTypes.default.any,
  onKeyDown: _propTypes.default.func,
  onKeyPress: _propTypes.default.func,
  onBlur: _propTypes.default.func,
  onFocus: _propTypes.default.func,

  /** Adds a css class to the input container element. */
  containerClassName: _propTypes.default.string,
  calendarProps: _propTypes.default.object,
  inputProps: _propTypes.default.object,
  isRtl: _propTypes.default.bool,
  messages: _propTypes.default.shape({
    dateButton: _propTypes.default.string,
    timeButton: _propTypes.default.string
  })
};

var defaultProps = _extends({}, _Calendar.default.defaultProps, {
  min: new Date(1900, 0, 1),
  max: new Date(2099, 11, 31),
  includeTime: true,
  selectIcon: _Icon.calendar,
  formats: {}
  /**
   * ---
   * subtitle: DatePicker, TimePicker
   * localized: true
   * shortcuts:
   *   - { key: alt + down arrow, label:  open calendar or time }
   *   - { key: alt + up arrow, label: close calendar or time }
   *   - { key: down arrow, label: move focus to next item }
   *   - { key: up arrow, label: move focus to previous item }
   *   - { key: home, label: move focus to first item }
   *   - { key: end, label: move focus to last item }
   *   - { key: enter, label: select focused item }
   *   - { key: any key, label: search list for item starting with key }
   * ---
   *
   * @public
   * @extends Calendar
   */

});

var DateTimePicker = _react.default.forwardRef(function (uncontrolledProps, outerRef) {
  var _useUncontrollable = (0, _hook.default)(uncontrolledProps, {
    open: 'onToggle',
    value: 'onChange',
    currentDate: 'onCurrentDateChange'
  }),
      id = _useUncontrollable.id,
      value = _useUncontrollable.value,
      onChange = _useUncontrollable.onChange,
      onSelect = _useUncontrollable.onSelect,
      onToggle = _useUncontrollable.onToggle,
      onKeyDown = _useUncontrollable.onKeyDown,
      onKeyPress = _useUncontrollable.onKeyPress,
      onCurrentDateChange = _useUncontrollable.onCurrentDateChange,
      inputProps = _useUncontrollable.inputProps,
      calendarProps = _useUncontrollable.calendarProps,
      timeInputProps = _useUncontrollable.timeInputProps,
      autoFocus = _useUncontrollable.autoFocus,
      tabIndex = _useUncontrollable.tabIndex,
      disabled = _useUncontrollable.disabled,
      readOnly = _useUncontrollable.readOnly,
      className = _useUncontrollable.className,
      containerClassName = _useUncontrollable.containerClassName,
      name = _useUncontrollable.name,
      selectIcon = _useUncontrollable.selectIcon,
      placeholder = _useUncontrollable.placeholder,
      includeTime = _useUncontrollable.includeTime,
      min = _useUncontrollable.min,
      max = _useUncontrollable.max,
      isRtl = _useUncontrollable.isRtl,
      open = _useUncontrollable.open,
      dropUp = _useUncontrollable.dropUp,
      parse = _useUncontrollable.parse,
      messages = _useUncontrollable.messages,
      formats = _useUncontrollable.formats,
      currentDate = _useUncontrollable.currentDate,
      popupTransition = _useUncontrollable.popupTransition,
      timePrecision = _useUncontrollable.timePrecision,
      ariaLabelledby = _useUncontrollable['aria-labelledby'],
      ariaDescribedby = _useUncontrollable['aria-describedby'],
      elementProps = _objectWithoutPropertiesLoose(_useUncontrollable, ["id", "value", "onChange", "onSelect", "onToggle", "onKeyDown", "onKeyPress", "onCurrentDateChange", "inputProps", "calendarProps", "timeInputProps", "autoFocus", "tabIndex", "disabled", "readOnly", "className", "containerClassName", "name", "selectIcon", "placeholder", "includeTime", "min", "max", "isRtl", "open", "dropUp", "parse", "messages", "formats", "currentDate", "popupTransition", "timePrecision", 'aria-labelledby', 'aria-describedby']);

  var localizer = _LocalizationProvider.default.useLocalizer(messages, formats);

  var ref = (0, _react.useRef)();
  var calRef = (0, _react.useRef)();
  var tabTrap = (0, _tabTrap.default)(calRef);
  var inputId = (0, _widgetHelpers.useInstanceId)(id, '_input');
  var dateId = (0, _widgetHelpers.useInstanceId)(id, '_date');
  var activeCalendarId = (0, _widgetHelpers.useInstanceId)(id, '_calendar_active_cell');
  var currentFormat = includeTime ? 'datetime' : 'date';
  var toggle = (0, _hooks.useDropodownToggle)(open, onToggle);

  var _useFocusManager = (0, _useFocusManager2.default)(ref, uncontrolledProps, {
    didHandle: function didHandle(focused) {
      if (!focused) {
        toggle.close();
        tabTrap.stop();
      } else if (open) {
        tabTrap.focus();
      }
    }
  }),
      focusEvents = _useFocusManager[0],
      focused = _useFocusManager[1];
  /**
   * Handlers
   */


  var useEditableCallback = (0, _interaction.createEditableCallback)(disabled || readOnly, ref);
  var handleChange = useEditableCallback(function (date, str, constrain) {
    if (constrain) date = inRangeValue(date);

    if (onChange) {
      if (date == null || value == null) {
        if (date != value //eslint-disable-line eqeqeq
        ) onChange(date, str);
      } else if (!_dates.default.eq(date, value)) {
        onChange(date, str);
      }
    }
  });
  var handleKeyDown = useEditableCallback(function (e) {
    (0, _widgetHelpers.notify)(onKeyDown, [e]);
    if (e.defaultPrevented) return;

    if (e.key === 'Escape' && open) {
      toggle.close();
    } else if (e.altKey) {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        toggle.open();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        toggle.close();
      }
    }
  });
  var handleKeyPress = useEditableCallback(function (e) {
    (0, _widgetHelpers.notify)(onKeyPress, [e]);
    if (e.defaultPrevented) return;
  });
  var handleDateSelect = useEditableCallback(function (date) {
    var _ref$current;

    var dateTime = _dates.default.merge(date, value, currentDate);

    var dateStr = formatDate(date);
    if (!includeTime) toggle.close();
    (0, _widgetHelpers.notify)(onSelect, [dateTime, dateStr]);
    handleChange(dateTime, dateStr, true);
    (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();
  });
  var handleTimeChange = useEditableCallback(function (date) {
    handleChange(date, formatDate(date), true);
  });
  var handleCalendarClick = useEditableCallback(function () {
    // this.focus()
    toggle();
  });

  var handleOpening = function handleOpening() {
    tabTrap.start();
    requestAnimationFrame(function () {
      tabTrap.focus();
    });
  };

  var handleClosing = function handleClosing() {
    tabTrap.stop();
    if (focused) focus();
  };
  /**
   * Methods
   */


  function focus() {
    var _ref$current2;

    if (open) calRef === null || calRef === void 0 ? void 0 : calRef.focus();else (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.focus();
  }

  function inRangeValue(value) {
    if (value == null) return value;
    return _dates.default.max(_dates.default.min(value, max), min);
  }

  function formatDate(date) {
    return date instanceof Date && !isNaN(date.getTime()) ? localizer.formatDate(date, currentFormat) : '';
  }

  (0, _react.useImperativeHandle)(outerRef, function () {
    return {
      focus: focus
    };
  });
  var shouldRenderList = (0, _widgetHelpers.useFirstFocusedRender)(focused, open);
  var inputReadOnly = (inputProps === null || inputProps === void 0 ? void 0 : inputProps.readOnly) != null ? inputProps === null || inputProps === void 0 ? void 0 : inputProps.readOnly : readOnly;
  return _react.default.createElement(_Widget.default, _extends({}, elementProps, {
    open: !!open,
    dropUp: dropUp,
    focused: focused,
    disabled: disabled,
    readOnly: readOnly,
    onKeyDown: handleKeyDown,
    onKeyPress: handleKeyPress
  }, focusEvents, {
    className: (0, _classnames.default)(className, 'rw-datetime-picker')
  }), _react.default.createElement(_WidgetPicker.default, {
    className: containerClassName
  }, _react.default.createElement(_DateTimePickerInput.default, _extends({}, inputProps, {
    id: inputId,
    ref: ref,
    role: "combobox",
    name: name,
    value: value,
    tabIndex: tabIndex,
    autoFocus: autoFocus,
    placeholder: placeholder,
    disabled: disabled,
    readOnly: inputReadOnly,
    format: currentFormat,
    editFormat: formats.editValue,
    editing: focused,
    localizer: localizer,
    parse: parse,
    onChange: handleChange,
    "aria-haspopup": true,
    "aria-labelledby": ariaLabelledby,
    "aria-describedby": ariaDescribedby,
    "aria-expanded": !!open,
    "aria-owns": dateId
  })), _react.default.createElement(_Select.default, {
    bordered: true
  }, _react.default.createElement(_Button.default, {
    icon: selectIcon,
    label: localizer.messages.dateButton(),
    disabled: disabled || readOnly,
    onClick: handleCalendarClick
  }))), !!shouldRenderList && _react.default.createElement(_Popup.default, {
    dropUp: dropUp,
    open: open,
    role: "dialog",
    className: "rw-calendar-popup",
    transition: popupTransition,
    onEntering: handleOpening,
    onExited: handleClosing
  }, _react.default.createElement("div", {
    ref: calRef,
    id: dateId
  }, _react.default.createElement(_Calendar.default, _extends({
    min: min,
    max: max
  }, calendarProps, {
    isRtl: isRtl,
    activeId: activeCalendarId,
    tabIndex: "-1",
    value: value,
    autoFocus: false,
    onChange: handleDateSelect,
    currentDate: currentDate,
    onCurrentDateChange: onCurrentDateChange,
    "aria-hidden": !open,
    "aria-live": "polite",
    "aria-labelledby": inputId
  })), includeTime && _react.default.createElement(_TimeInput.default, _extends({}, timeInputProps, {
    value: value,
    precision: timePrecision,
    onChange: handleTimeChange,
    datePart: currentDate
  })))));
});

DateTimePicker.displayName = 'DateTimePicker';
DateTimePicker.propTypes = propTypes;
DateTimePicker.defaultProps = defaultProps;
var _default = DateTimePicker;
exports.default = _default;
module.exports = exports["default"];