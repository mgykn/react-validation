"use strict";

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _hook = _interopRequireDefault(require("uncontrollable/hook"));

var _useTimeout = _interopRequireDefault(require("@restart/hooks/useTimeout"));

var _List = _interopRequireDefault(require("./List"));

var _Widget = _interopRequireDefault(require("./Widget"));

var _SelectListItem = _interopRequireDefault(require("./SelectListItem"));

var _ = require("./util/_");

var _A11y = require("./util/A11y");

var _messages = require("./messages");

var CustomPropTypes = _interopRequireWildcard(require("./util/PropTypes"));

var _hooks = require("./util/hooks");

var _interaction = require("./util/interaction");

var _widgetHelpers = require("./util/widgetHelpers");

var _getAccessors = require("./util/getAccessors");

var _useFocusManager2 = _interopRequireDefault(require("./util/useFocusManager"));

var _useScrollManager = _interopRequireDefault(require("./util/useScrollManager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var BusyMask = function BusyMask() {
  return _react.default.createElement("span", {
    className: "rw-loading-mask"
  });
};

function getFirstValue(data, values) {
  if (!values.length) return null;

  for (var idx = 0; idx < data.length; idx++) {
    if (~values.indexOf(data[idx])) return data[idx];
  }

  return null;
}

var propTypes = {
  data: _propTypes.default.array,
  value: _propTypes.default.oneOfType([_propTypes.default.any, _propTypes.default.array]),
  onChange: _propTypes.default.func,

  /**
   * A handler called when focus shifts on the SelectList. Internally this is used to ensure the focused item is in view.
   * If you want to define your own "scrollTo" behavior or just disable the default one specify an `onMove` handler.
   * The handler is called with the relevant DOM nodes needed to implement scroll behavior: the list element,
   * the element that is currently focused, and a focused value.
   *
   * @type {function(list: HTMLELement, focusedNode: HTMLElement, focusedItem: any)}
   */
  onMove: _propTypes.default.func,

  /**
   * Whether or not the SelectList allows multiple selection or not. when `false` the SelectList will
   * render as a list of radio buttons, and checkboxes when `true`.
   */
  multiple: _propTypes.default.bool,
  onKeyDown: _propTypes.default.func,
  onKeyPress: _propTypes.default.func,
  itemComponent: CustomPropTypes.elementType,
  busySpinner: _propTypes.default.node,
  listComponent: CustomPropTypes.elementType,
  groupComponent: CustomPropTypes.elementType,
  groupBy: CustomPropTypes.accessor,
  valueField: CustomPropTypes.accessor,
  textField: CustomPropTypes.accessor,
  busy: _propTypes.default.bool,
  delay: _propTypes.default.number,
  autoFocus: _propTypes.default.bool,
  disabled: CustomPropTypes.disabled.acceptsArray,
  readOnly: CustomPropTypes.disabled,
  listProps: _propTypes.default.object,
  tabIndex: _propTypes.default.any,

  /**
   * The HTML `name` attribute used to group checkboxes and radio buttons
   * together.
   */
  name: _propTypes.default.string,
  isRtl: _propTypes.default.bool,
  messages: _propTypes.default.shape({
    emptyList: CustomPropTypes.message
  })
};
var defaultProps = {
  delay: 250,
  data: [],
  busySpinner: _react.default.createElement(BusyMask, null),
  listComponent: _List.default
  /**
   * ---
   * shortcuts:
   *   - { key: down arrow, label: move focus, or select previous option }
   *   - { key: up arrow, label: move focus, or select next option }
   *   - { key: home, label: move focus to first option }
   *   - { key: end, label: move focus to last option }
   *   - { key: spacebar, label: toggle focused option }
   *   - { key: ctrl + a, label: ctoggle select all/select none }
   *   - { key: any key, label: search list for option starting with key }
   * ---
   *
   * A group of radio buttons or checkboxes bound to a dataset.
   *
   * @public
   */

};

var SelectList = _react.default.forwardRef(function (uncontrolledProps, outerRef) {
  var _useUncontrollable = (0, _hook.default)(uncontrolledProps, {
    value: 'onChange'
  }),
      id = _useUncontrollable.id,
      autoFocus = _useUncontrollable.autoFocus,
      textField = _useUncontrollable.textField,
      valueField = _useUncontrollable.valueField,
      data = _useUncontrollable.data,
      value = _useUncontrollable.value,
      delay = _useUncontrollable.delay,
      multiple = _useUncontrollable.multiple,
      className = _useUncontrollable.className,
      busy = _useUncontrollable.busy,
      disabled = _useUncontrollable.disabled,
      readOnly = _useUncontrollable.readOnly,
      busySpinner = _useUncontrollable.busySpinner,
      tabIndex = _useUncontrollable.tabIndex,
      name = _useUncontrollable.name,
      onChange = _useUncontrollable.onChange,
      onKeyPress = _useUncontrollable.onKeyPress,
      onKeyDown = _useUncontrollable.onKeyDown,
      listProps = _useUncontrollable.listProps,
      itemComponent = _useUncontrollable.itemComponent,
      groupComponent = _useUncontrollable.groupComponent,
      List = _useUncontrollable.listComponent,
      userMessages = _useUncontrollable.messages,
      elementProps = _objectWithoutPropertiesLoose(_useUncontrollable, ["id", "autoFocus", "textField", "valueField", "data", "value", "delay", "multiple", "className", "busy", "disabled", "readOnly", "busySpinner", "tabIndex", "name", "onChange", "onKeyPress", "onKeyDown", "listProps", "itemComponent", "groupComponent", "listComponent", "messages"]);

  var ref = (0, _react.useRef)();
  var listRef = (0, _react.useRef)();
  var clickingRef = (0, _react.useRef)(false);
  var searchingRef = (0, _react.useRef)('');
  var widgetId = (0, _widgetHelpers.useInstanceId)(id, '_widget');
  var listId = (0, _widgetHelpers.useInstanceId)(id, '_listbox');
  var activeId = (0, _widgetHelpers.useInstanceId)(id, '_listbox_active_option');
  var itemName = (0, _widgetHelpers.useInstanceId)(id, '_name');
  var accessors = (0, _getAccessors.useAccessors)(textField, valueField);
  var messages = (0, _messages.useMessagesWithDefaults)(userMessages);
  var timeout = (0, _useTimeout.default)();
  (0, _hooks.useAutoFocus)(autoFocus, ref);
  var handleScroll = (0, _useScrollManager.default)(ref);
  var list = (0, _hooks.useList)(data, {
    nextProps: uncontrolledProps
  });

  var _useState = (0, _react.useState)(null),
      focusedItem = _useState[0],
      setFocusedItem = _useState[1];

  var _useFocusManager = (0, _useFocusManager2.default)(ref, uncontrolledProps, {
    didHandle: function didHandle(nextFocused) {
      // the rigamarole here is to avoid flicker went clicking an item and
      // gaining focus at the same time.
      if (nextFocused !== focused) {
        if (!nextFocused) setFocusedItem(null);else if (nextFocused && !clickingRef.current) {
          var allowed = Array.isArray(disabled) ? dataItems.filter(function (v) {
            return !accessors.includes(disabled, v);
          }) : dataItems;
          setFocusedItem(getFirstValue(data, allowed) || list.nextEnabled(data[0]));
        }
        clickingRef.current = false;
      }
    }
  }),
      focusEvents = _useFocusManager[0],
      focused = _useFocusManager[1];

  var dataItems = (0, _react.useMemo)(function () {
    return (0, _.makeArray)(value).map(function (item) {
      return accessors.findOrSelf(data, item);
    });
  }, [data, value, accessors]);
  (0, _A11y.useActiveDescendant)(ref, activeId, true, [focusedItem]);
  var isDisabled = disabled === true;
  var isReadOnly = !!readOnly;
  var useEditableCallback = (0, _interaction.createEditableCallback)(isDisabled || isReadOnly, ref);

  var handleMouseDown = function handleMouseDown() {
    clickingRef.current = true;
  }; // @widgetEditable


  var handleKeyDown = useEditableCallback(function (event) {
    var keyCode = event.keyCode,
        key = event.key,
        ctrlKey = event.ctrlKey;

    var change = function change(item) {
      if (!item) return;
      var checked = multiple ? !accessors.includes(dataItems, item) // toggle value
      : true;
      handleChange(item, checked, event);
    };

    (0, _widgetHelpers.notify)(onKeyDown, [event]);
    if (event.defaultPrevented) return;

    if (key === 'End') {
      event.preventDefault();
      var nextFocusedItem = list.last();
      setFocusedItem(nextFocusedItem);
      if (!multiple) change(focusedItem);
    } else if (key === 'Home') {
      event.preventDefault();

      var _nextFocusedItem = list.first();

      setFocusedItem(_nextFocusedItem);
      if (!multiple) change(focusedItem);
    } else if (key === 'Enter' || key === ' ') {
      event.preventDefault();
      change(focusedItem);
    } else if (key === 'ArrowDown' || key === 'ArrowRight') {
      event.preventDefault();

      var _nextFocusedItem2 = list.next(focusedItem);

      setFocusedItem(_nextFocusedItem2);
      if (!multiple) change(_nextFocusedItem2);
    } else if (key === 'ArrowUp' || key === 'ArrowLeft') {
      event.preventDefault();

      var _nextFocusedItem3 = list.prev(focusedItem);

      setFocusedItem(_nextFocusedItem3);
      if (!multiple) change(_nextFocusedItem3);
    } else if (multiple && keyCode === 65 && ctrlKey) {
      event.preventDefault();
      selectAll();
    }
  });
  var handleKeyPress = useEditableCallback(function (event) {
    (0, _widgetHelpers.notify)(onKeyPress, [event]);
    if (event.defaultPrevented) return;
    search(String.fromCharCode(event.which), event);
  });

  var handleChange = function handleChange(item, checked, originalEvent) {
    var lastValue = dataItems;
    setFocusedItem(item);
    if (!multiple) return (0, _widgetHelpers.notify)(onChange, [checked ? item : null, {
      originalEvent: originalEvent,
      lastValue: lastValue,
      checked: checked
    }]);
    var nextValue = checked ? lastValue.concat(item) : lastValue.filter(function (v) {
      return v !== item;
    });
    (0, _widgetHelpers.notify)(onChange, [nextValue || [], {
      checked: checked,
      lastValue: lastValue,
      originalEvent: originalEvent,
      dataItem: item
    }]);
  };

  function selectAll() {
    var disabledItems = Array.isArray(disabled) ? disabled : [];
    var disabledValues;
    var enabledData = data;

    if (disabledItems.length) {
      disabledValues = dataItems.filter(function (v) {
        return accessors.includes(disabledItems, v);
      });
      enabledData = data.filter(function (v) {
        return !accessors.includes(disabledItems, v);
      });
    }

    var nextValues = dataItems.length >= enabledData.length ? dataItems.filter(function (v) {
      return accessors.includes(disabledItems, v);
    }) : enabledData.concat(disabledValues);
    (0, _widgetHelpers.notify)(onChange, [nextValues]);
  }

  (0, _react.useImperativeHandle)(outerRef, function () {
    return {
      selectAll: selectAll,
      focus: function focus() {
        var _listRef$current;

        (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.focus();
      }
    };
  }, [disabled, dataItems, onChange, data]);

  function search(character, originalEvent) {
    var word = ("" + searchingRef.current + character).toLowerCase();
    if (!multiple) originalEvent.persist();
    if (!character) return;
    searchingRef.current = word;
    timeout.set(function () {
      var nextFocusedItem = list.next(focusedItem, word);
      searchingRef.current = '';

      if (nextFocusedItem) {
        if (!multiple) handleChange(nextFocusedItem, true, originalEvent);else setFocusedItem(nextFocusedItem);
      }
    }, delay);
  }

  var renderListItem = function renderListItem(itemProps) {
    return _react.default.createElement(_SelectListItem.default, _extends({}, itemProps, {
      name: name || itemName,
      type: multiple ? 'checkbox' : 'radio',
      readOnly: disabled === true || readOnly,
      onChange: handleChange,
      onMouseDown: handleMouseDown,
      checked: accessors.includes(dataItems, itemProps.dataItem)
    }));
  };

  return _react.default.createElement(_Widget.default, _extends({}, elementProps, focusEvents, {
    id: widgetId,
    onKeyDown: handleKeyDown,
    onKeyPress: handleKeyPress,
    focused: focused,
    disabled: disabled,
    readOnly: readOnly,
    role: "radiogroup",
    "aria-busy": !!busy,
    "aria-activedescendant": activeId,
    ref: ref,
    className: (0, _classnames.default)(className, 'rw-select-list', 'rw-widget-input', 'rw-widget-container')
  }), _react.default.createElement(List, _extends({}, listProps, {
    role: "radiogroup",
    tabIndex: tabIndex || '0',
    id: listId,
    activeId: activeId,
    data: data,
    dataState: list.dataState,
    isDisabled: list.isDisabled,
    textAccessor: accessors.text,
    valueAccessor: accessors.value,
    itemComponent: itemComponent,
    groupComponent: groupComponent,
    optionComponent: renderListItem,
    focusedItem: focused && !disabled && !readOnly && focusedItem,
    onMove: handleScroll,
    messages: {
      emptyList: messages.emptyList
    },
    ref: listRef
  })), busy && busySpinner);
});

SelectList.propTypes = propTypes;
SelectList.defaultProps = defaultProps;
var _default = SelectList;
exports.default = _default;
module.exports = exports["default"];