"use strict";

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _hook = _interopRequireDefault(require("uncontrollable/hook"));

var _Widget = _interopRequireDefault(require("./Widget"));

var _CalendarHeader = _interopRequireDefault(require("./CalendarHeader"));

var _Month = _interopRequireDefault(require("./Month"));

var _Year = _interopRequireDefault(require("./Year"));

var _Decade = _interopRequireDefault(require("./Decade"));

var _Century = _interopRequireDefault(require("./Century"));

var _LocalizationProvider = _interopRequireDefault(require("./LocalizationProvider"));

var _SlideTransitionGroup = _interopRequireDefault(require("./SlideTransitionGroup"));

var _useFocusManager2 = _interopRequireDefault(require("./util/useFocusManager"));

var CustomPropTypes = _interopRequireWildcard(require("./util/PropTypes"));

var _dates = _interopRequireDefault(require("./util/dates"));

var _widgetHelpers = require("./util/widgetHelpers");

var _interaction = require("./util/interaction");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function useAutoFocus(autoFocus, ref) {
  (0, _react.useEffect)(function () {
    if (autoFocus) ref.current.focus();
  }, []);
}

var last = function last(a) {
  return a[a.length - 1];
};

var CELL_CLASSNAME = 'rw-cell';
var FOCUSED_CELL_SELECTOR = "." + CELL_CLASSNAME + "[tabindex]";
var VIEW_UNIT = {
  month: 'day',
  year: 'month',
  decade: 'year',
  century: 'decade'
};
var VIEW_OPTIONS = ['month', 'year', 'decade', 'century'];
var VIEW = {
  month: _Month.default,
  year: _Year.default,
  decade: _Decade.default,
  century: _Century.default
};
var ARROWS_TO_DIRECTION = {
  ArrowDown: 'DOWN',
  ArrowUp: 'UP',
  ArrowRight: 'RIGHT',
  ArrowLeft: 'LEFT'
};
var OPPOSITE_DIRECTION = {
  LEFT: 'RIGHT',
  RIGHT: 'LEFT'
};
var MULTIPLIER = {
  year: 1,
  decade: 10,
  century: 100
};

function inRangeValue(_value, min, max) {
  var value = dateOrNull(_value);
  if (value === null) return value;
  return _dates.default.max(_dates.default.min(value, max), min);
}

var propTypes = {
  /**
   * @example ['disabled', ['new Date()']]
   */
  disabled: CustomPropTypes.disabled,

  /**
   * @example ['readOnly', ['new Date()']]
   */
  readOnly: CustomPropTypes.disabled,

  /**
   * @example ['onChangePicker', [ ['new Date()'] ]]
   */
  onChange: _propTypes.default.func,

  /**
   * @example ['valuePicker', [ ['new Date()'] ]]
   */
  value: _propTypes.default.instanceOf(Date),

  /**
   * The minimum date that the Calendar can navigate from.
   *
   * @example ['prop', ['min', 'new Date()']]
   */
  min: _propTypes.default.instanceOf(Date).isRequired,

  /**
   * The maximum date that the Calendar can navigate to.
   *
   * @example ['prop', ['max', 'new Date()']]
   */
  max: _propTypes.default.instanceOf(Date).isRequired,

  /**
   * Default current date at which the calendar opens. If none is provided, opens at today's date or the `value` date (if any).
   */
  currentDate: _propTypes.default.instanceOf(Date),

  /**
   * Change event Handler that is called when the currentDate is changed. The handler is called with the currentDate object.
   */
  onCurrentDateChange: _propTypes.default.func,

  /** Specify the navigate into the past header icon */
  navigatePrevIcon: _propTypes.default.node,

  /** Specify the navigate into the future header icon */
  navigateNextIcon: _propTypes.default.node,

  /**
   * Controls the currently displayed calendar view. Use `defaultView` to set a unique starting view.
   *
   * @type {("month"|"year"|"decade"|"century")}
   * @controllable onViewChange
   */
  view: function view(props) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return _propTypes.default.oneOf(props.views || VIEW_OPTIONS).apply(void 0, [props].concat(args));
  },

  /**
   * Defines a list of views the Calendar can traverse through, starting with the
   * first in the list to the last.
   *
   * @type array<"month"|"year"|"decade"|"century">
   */
  views: _propTypes.default.arrayOf(_propTypes.default.oneOf(VIEW_OPTIONS)).isRequired,

  /**
   * A callback fired when the `view` changes.
   *
   * @controllable view
   */
  onViewChange: _propTypes.default.func,

  /**
   * Callback fired when the Calendar navigates between views, or forward and backwards in time.
   *
   * @type function(date: ?Date, direction: string, view: string)
   */
  onNavigate: _propTypes.default.func,
  culture: _propTypes.default.string,
  autoFocus: _propTypes.default.bool,

  /**
   * Show or hide the Calendar footer.
   *
   * @example ['prop', ['footer', true]]
   */
  footer: _propTypes.default.bool,

  /**
   * Provide a custom component to render the days of the month. The Component is provided the following props
   *
   * - `date`: a `Date` object for the day of the month to render
   * - `label`: a formatted `string` of the date to render. To adjust the format of the `label` string use the `dateFormat` prop, listed below.
   */
  dayComponent: CustomPropTypes.elementType,
  formats: _propTypes.default.shape({
    /**
     * A formatter for the header button of the month view.
     *
     * @example ['dateFormat', ['headerFormat', "{ date: 'medium' }"]]
     */
    header: CustomPropTypes.dateFormat,

    /**
     * A formatter for the Calendar footer, formats today's Date as a string.
     *
     * @example ['dateFormat', ['footerFormat', "{ date: 'medium' }", "date => 'Today is: ' + formatter(date)"]]
     */
    footer: CustomPropTypes.dateFormat,

    /**
     * A formatter calendar days of the week, the default formats each day as a Narrow name: "Mo", "Tu", etc.
     *
     * @example ['prop', { day: "day => \n['ðŸŽ‰', 'M', 'T','W','Th', 'F', 'ðŸŽ‰'][day.getDay()]" }]
     */
    day: CustomPropTypes.dateFormat,

    /**
     * A formatter for day of the month
     *
     * @example ['prop', { date: "dt => String(dt.getDate())" }]
     */
    date: CustomPropTypes.dateFormat,

    /**
     * A formatter for month name.
     *
     * @example ['dateFormat', ['monthFormat', "{ raw: 'MMMM' }", null, { defaultView: '"year"' }]]
     */
    month: CustomPropTypes.dateFormat,

    /**
     * A formatter for month name.
     *
     * @example ['dateFormat', ['yearFormat', "{ raw: 'yy' }", null, { defaultView: '"decade"' }]]
     */
    year: CustomPropTypes.dateFormat,

    /**
     * A formatter for decade, the default formats the first and last year of the decade like: 2000 - 2009.
     */
    decade: CustomPropTypes.dateFormat,

    /**
     * A formatter for century, the default formats the first and last year of the century like: 1900 - 1999.
     */
    century: CustomPropTypes.dateFormat
  }),
  isRtl: _propTypes.default.bool,
  messages: _propTypes.default.shape({
    moveBack: _propTypes.default.string,
    moveForward: _propTypes.default.string
  }),
  onKeyDown: _propTypes.default.func,

  /** @ignore */
  tabIndex: _propTypes.default.any
};

var useViewState = function useViewState(views, view, value, currentDate) {
  if (view === void 0) {
    view = views[0];
  }

  var lastView = (0, _react.useRef)(view);
  var lastDate = (0, _react.useRef)(currentDate);
  var slideDirection;

  if (view !== lastView.current) {
    slideDirection = views.indexOf(lastView.current) > views.indexOf(view) ? 'top' : 'bottom';
  } else if (lastDate.current !== currentDate) {
    slideDirection = _dates.default.gt(currentDate, lastDate.current) ? 'left' : 'right';
  }

  var nextCurrent = currentDate || value || new Date();
  (0, _react.useEffect)(function () {
    lastDate.current = nextCurrent;
    lastView.current = view;
  });
  return [view, slideDirection, nextCurrent];
};
/**
 * ---
 * localized: true
 * shortcuts:
 *   - { key: ctrl + down arrow, label: navigate to next view }
 *   - { key: ctrl + up arrow, label: navigate to previous view }
 *   - { key: ctrl + left arrow, label: "navigate to previous: month, year, decade, or century" }
 *   - { key: ctrl + right arrow, label: "navigate to next: month, year, decade, or century" }
 *   - { key: left arrow, label:  move focus to previous date}
 *   - { key: right arrow, label: move focus to next date }
 *   - { key: up arrow, label: move focus up within view }
 *   - { key: down key, label: move focus down within view }
 * ---
 *
 * @public
 */


function Calendar(uncontrolledProps) {
  var _useUncontrollable = (0, _hook.default)(uncontrolledProps, {
    value: 'onChange',
    currentDate: 'onCurrentDateChange',
    view: 'onViewChange'
  }),
      id = _useUncontrollable.id,
      autoFocus = _useUncontrollable.autoFocus,
      views = _useUncontrollable.views,
      tabIndex = _useUncontrollable.tabIndex,
      disabled = _useUncontrollable.disabled,
      readOnly = _useUncontrollable.readOnly,
      className = _useUncontrollable.className,
      value = _useUncontrollable.value,
      min = _useUncontrollable.min,
      max = _useUncontrollable.max,
      onChange = _useUncontrollable.onChange,
      onCurrentDateChange = _useUncontrollable.onCurrentDateChange,
      onViewChange = _useUncontrollable.onViewChange,
      onKeyDown = _useUncontrollable.onKeyDown,
      onNavigate = _useUncontrollable.onNavigate,
      isRtl = _useUncontrollable.isRtl,
      messages = _useUncontrollable.messages,
      formats = _useUncontrollable.formats,
      pView = _useUncontrollable.view,
      pCurrentDate = _useUncontrollable.currentDate; // console.log(value, currentDate, uncontrolledProps)


  var localizer = _LocalizationProvider.default.useLocalizer(messages, formats);

  var ref = (0, _react.useRef)();
  var viewId = (0, _widgetHelpers.useInstanceId)(id, '_calendar');
  var labelId = (0, _widgetHelpers.useInstanceId)(id, '_calendar_label');
  useAutoFocus(autoFocus, ref);

  var _useViewState = useViewState(views, pView, value, pCurrentDate),
      view = _useViewState[0],
      slideDirection = _useViewState[1],
      currentDate = _useViewState[2];

  var _useFocusManager = (0, _useFocusManager2.default)(ref, {
    willHandle: function willHandle() {
      if (tabIndex == -1) return false;
    }
  }),
      focused = _useFocusManager[1];

  var lastValue = (0, _react.useRef)(value);
  (0, _react.useEffect)(function () {
    var inValue = inRangeValue(value, min, max);
    var last = lastValue.current;
    lastValue.current = value;
    if (!_dates.default.eq(inValue, dateOrNull(last), VIEW_UNIT[view])) maybeSetCurrentDate(inValue);
  });
  var isDisabled = disabled || readOnly; // const isValidView = next => views.indexOf(next) !== -1

  /**
   * Handlers
   */

  var useEditableCallback = (0, _interaction.createEditableCallback)(isDisabled, ref);
  var handleViewChange = useEditableCallback(function () {
    navigate('UP');
  });
  var handleMoveBack = useEditableCallback(function () {
    navigate('LEFT');
  });
  var handleMoveForward = useEditableCallback(function () {
    navigate('RIGHT');
  });
  var handleChange = useEditableCallback(function (date) {
    if (views[0] === view) {
      maybeSetCurrentDate(date);
      (0, _widgetHelpers.notify)(onChange, date);
      focus();
      return;
    }

    navigate('DOWN', date);
  });
  var handleMoveToday = useEditableCallback(function () {
    var date = new Date();
    var firstView = views[0];
    (0, _widgetHelpers.notify)(onChange, date);

    if (_dates.default.inRange(date, min, max, firstView)) {
      focus();
      maybeSetCurrentDate(date);
      (0, _widgetHelpers.notify)(onViewChange, [firstView]);
    }
  });
  var handleKeyDown = useEditableCallback(function (e) {
    var ctrl = e.ctrlKey || e.metaKey;
    var key = e.key;
    var direction = ARROWS_TO_DIRECTION[key];
    var unit = VIEW_UNIT[view];

    if (key === 'Enter') {
      e.preventDefault();
      return handleChange(currentDate);
    }

    if (direction) {
      if (ctrl) {
        e.preventDefault();
        navigate(direction);
      } else {
        if (isRtl && OPPOSITE_DIRECTION[direction]) direction = OPPOSITE_DIRECTION[direction];

        var _nextDate = Calendar.move(currentDate, min, max, view, direction);

        if (!_dates.default.eq(currentDate, _nextDate, unit)) {
          e.preventDefault();
          if (_dates.default.gt(_nextDate, currentDate, view)) navigate('RIGHT', _nextDate);else if (_dates.default.lt(_nextDate, currentDate, view)) navigate('LEFT', _nextDate);else maybeSetCurrentDate(_nextDate);
        }
      }
    }

    (0, _widgetHelpers.notify)(onKeyDown, [e]);
  });

  function navigate(direction, date) {
    var nextView = view;
    var slideDir = direction === 'LEFT' || direction === 'UP' ? 'right' : 'left';
    if (direction === 'UP') nextView = views[views.indexOf(view) + 1] || nextView;
    if (direction === 'DOWN') nextView = views[views.indexOf(view) - 1] || nextView;
    if (!date) date = ['LEFT', 'RIGHT'].indexOf(direction) !== -1 ? nextDate(direction) : currentDate;

    if (_dates.default.inRange(date, min, max, nextView)) {
      (0, _widgetHelpers.notify)(onNavigate, [date, slideDir, nextView]); //this.focus()

      maybeSetCurrentDate(date);
      (0, _widgetHelpers.notify)(onViewChange, [nextView]);
    }
  }

  var focus = function focus() {
    var _ref$current, _ref$current$querySel;

    (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : (_ref$current$querySel = _ref$current.querySelector(FOCUSED_CELL_SELECTOR)) === null || _ref$current$querySel === void 0 ? void 0 : _ref$current$querySel.focus();
  };

  var moveFocus = function moveFocus(node, hadFocus) {
    var current = document.activeElement;

    if (hadFocus && (!current || !node.contains(current))) {
      node.focus();
    }
  };

  function maybeSetCurrentDate(date) {
    var inRangeDate = inRangeValue(date ? new Date(date) : currentDate, min, max);
    if (date === currentDate || _dates.default.eq(inRangeDate, dateOrNull(currentDate), VIEW_UNIT[view])) return;
    (0, _widgetHelpers.notify)(onCurrentDateChange, inRangeDate);
  }

  function nextDate(direction) {
    var method = direction === 'LEFT' ? 'subtract' : 'add';
    var unit = view === 'month' ? view : 'year';
    var multi = MULTIPLIER[view] || 1;
    return _dates.default[method](currentDate, 1 * multi, unit);
  }

  function getHeaderLabel() {
    switch (view) {
      case 'month':
        return localizer.formatDate(currentDate, 'header');

      case 'year':
        return localizer.formatDate(currentDate, 'year');

      case 'decade':
        return localizer.formatDate(_dates.default.startOf(currentDate, 'decade'), 'decade');

      case 'century':
        return localizer.formatDate(_dates.default.startOf(currentDate, 'century'), 'century');
    }
  }

  var View = VIEW[view];
  var todayNotInRange = !_dates.default.inRange(new Date(), min, max, view);

  var key = view + '_' + _dates.default[view](currentDate); // let elementProps = Props.pickElementProps(this),
  // let viewProps = pick(uncontrolledProps, View)


  var prevDisabled = isDisabled || !_dates.default.inRange(nextDate('LEFT'), min, max, view);
  var nextDisabled = isDisabled || !_dates.default.inRange(nextDate('RIGHT'), min, max, view);
  return _react.default.createElement(_Widget.default // {...elementProps}
  , {
    role: "group",
    ref: ref,
    focused: focused,
    disabled: disabled,
    readOnly: readOnly,
    tabIndex: tabIndex || 0,
    className: (0, _classnames.default)(className, 'rw-calendar rw-widget-container')
  }, _react.default.createElement(_CalendarHeader.default, {
    isRtl: isRtl,
    label: getHeaderLabel(),
    labelId: labelId,
    localizer: localizer,
    upDisabled: isDisabled || view === last(views),
    prevDisabled: prevDisabled,
    todayDisabled: disabled || todayNotInRange,
    nextDisabled: nextDisabled,
    onViewChange: handleViewChange,
    onMoveLeft: handleMoveBack,
    onMoveRight: handleMoveForward,
    onMoveToday: handleMoveToday
  }), _react.default.createElement(Calendar.Transition, {
    direction: slideDirection,
    onTransitionEnd: moveFocus
  }, _react.default.createElement(View, _extends({}, uncontrolledProps, {
    key: key,
    id: viewId,
    value: value,
    localizer: localizer,
    disabled: disabled,
    focusedItem: currentDate,
    onChange: handleChange,
    onKeyDown: handleKeyDown,
    "aria-labelledby": labelId
  }))));
}

function dateOrNull(dt) {
  if (dt && !isNaN(dt.getTime())) return dt;
  return null;
}

Calendar.displayName = 'Calendar';
Calendar.propTypes = propTypes;
Calendar.defaultProps = {
  min: new Date(1900, 0, 1),
  max: new Date(2099, 11, 31),
  views: VIEW_OPTIONS,
  tabIndex: '0'
};
Calendar.Transition = _SlideTransitionGroup.default;

Calendar.move = function (date, min, max, unit, direction) {
  var isMonth = unit === 'month';
  var isUpOrDown = direction === 'UP' || direction === 'DOWN';
  var rangeUnit = VIEW_UNIT[unit];
  var addUnit = isMonth && isUpOrDown ? 'week' : VIEW_UNIT[unit];
  var amount = isMonth || !isUpOrDown ? 1 : 4;
  var newDate;
  if (direction === 'UP' || direction === 'LEFT') amount *= -1;
  newDate = _dates.default.add(date, amount, addUnit);
  return _dates.default.inRange(newDate, min, max, rangeUnit) ? newDate : date;
};

var _default = Calendar;
exports.default = _default;
module.exports = exports["default"];