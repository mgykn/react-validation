"use strict";

exports.__esModule = true;
exports.default = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _hook = _interopRequireDefault(require("uncontrollable/hook"));

var _querySelectorAll = _interopRequireDefault(require("dom-helpers/query/querySelectorAll"));

var _dates = _interopRequireDefault(require("./util/dates"));

var _useFocusManager2 = _interopRequireDefault(require("./util/useFocusManager"));

var _interaction = require("./util/interaction");

var _Button = _interopRequireDefault(require("./Button"));

var _Widget = _interopRequireDefault(require("./Widget"));

var _Icon = require("./Icon");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var selectTextRange = function selectTextRange(el) {
  if (el.select) return el.select();
  var range = document.createRange();
  range.selectNodeContents(el);
  window.getSelection().removeAllRanges();
  window.getSelection().addRange(range);
};

var padStart = function padStart(str, len, pad) {
  str = String(str == null ? '' : str);

  while (str.length < len) {
    str = pad + str;
  }

  return str;
}; // prettier-ignore


var isEmptyValue = function isEmptyValue(p, precision) {
  return p.hours == null && p.minutes == null && (precision != 'seconds' && precision !== 'milliseconds' || p.seconds == null) && (precision !== 'milliseconds' || p.milliseconds == null);
}; // prettier-ignore


var isPartialValue = function isPartialValue(p, precision) {
  return p.hours == null || p.minutes == null || (precision === 'seconds' || precision === 'milliseconds') && p.seconds == null || precision === 'milliseconds' && p.milliseconds == null;
};

var getValueParts = function getValueParts(value, use12HourClock) {
  var hours, minutes, seconds, milliseconds;
  var meridiem = 'AM';

  if (value) {
    hours = value.getHours();

    if (use12HourClock) {
      meridiem = hours < 12 ? 'AM' : 'PM';
      hours = hours % 12 || 12;
    }

    minutes = value.getMinutes();
    seconds = value.getSeconds();
    milliseconds = value.getMilliseconds();
  }

  return {
    hours: hours,
    minutes: minutes,
    seconds: seconds,
    milliseconds: milliseconds,
    meridiem: meridiem
  };
};

var TESTS = {
  hours: /^([1]?[0-9]|2[0-3])$/,
  hours12: /^^(1[0-2]|0?[1-9])$$/,
  minutes: /^([0-5]?\d)$/,
  seconds: /^([0-5]?\d)$/,
  milliseconds: /^(\d{1,3})$/
};

var isValid = function isValid(value, part, use12HourClock) {
  if (part === 'hours') part = !use12HourClock ? 'hours' : 'hours12';
  return TESTS[part].test(value);
};
/* eslint-disable react/prop-types */


var TimePartInput = function TimePartInput(_ref) {
  var value = _ref.value,
      pad = _ref.pad,
      innerRef = _ref.innerRef,
      placeholder = _ref.placeholder,
      min = _ref.min,
      max = _ref.max,
      emptyChar = _ref.emptyChar,
      props = _objectWithoutPropertiesLoose(_ref, ["value", "pad", "innerRef", "placeholder", "min", "max", "emptyChar"]);

  return _react.default.createElement("input", _extends({}, props, {
    ref: innerRef,
    "data-focusable": true,
    autoComplete: "off",
    role: "spinbutton",
    "aria-valuenow": value,
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuetext": value == null ? '' : value // seems readonly is not valid
    ,
    "aria-disabled": props.disabled || props.readOnly,
    placeholder: placeholder,
    className: "rw-input-reset rw-time-part-input",
    value: placeholder && !value ? '' : padStart(value, pad || 0, value == null ? emptyChar : '0')
  }));
};
/* eslint-enable react/prop-types */


var propTypes = {
  value: _propTypes.default.instanceOf(Date),
  onChange: _propTypes.default.func,

  /**
   * The default date used to construct a new time when the `value` is empty
   *
   * @default new Date()
   **/
  datePart: _propTypes.default.instanceOf(Date),

  /**
   * Use a 12 hour clock (with AM/PM) instead of 24 hour one.
   * The configured localizer may provide a default value .
   **/
  use12HourClock: _propTypes.default.bool,

  /** Time part values will be padded by `0` */
  padValues: _propTypes.default.bool,

  /** The string character used to pad empty, or cleared values */
  emptyCharacter: _propTypes.default.string,

  /** Hide the input clear button */
  noClearButton: _propTypes.default.bool,
  disabled: _propTypes.default.bool,
  readOnly: _propTypes.default.bool,

  /** Controls how precise of a time can be input **/
  precision: _propTypes.default.oneOf(['minutes', 'seconds', 'milliseconds']).isRequired,

  /**
   * The seperator between hours and minutes
   * @default ':'
   */
  hoursAddon: _propTypes.default.node,

  /**
   * The seperator between hours and minutes
   * @default ':'
   */
  minutesAddon: _propTypes.default.node,

  /**
   * The seperator between hours and minutes
   * @default ':'
   */
  secondsAddon: _propTypes.default.node,

  /**
   * The seperator between hours and minutes
   * @default '.'
   */
  millisecondsAddon: _propTypes.default.node
};
var defaultProps = {
  hoursAddon: ':',
  padValues: true,
  precision: 'minutes',
  emptyCharacter: '-'
};
var count = 0;

function useTimePartState(value, use12HourClock) {
  var _useState = (0, _react.useState)(function () {
    return {
      value: value,
      use12HourClock: use12HourClock,
      timeParts: getValueParts(value, use12HourClock)
    };
  }),
      state = _useState[0],
      setState = _useState[1];

  var setTimeParts = (0, _react.useCallback)(function (timeParts) {
    return setState(function (s) {
      return _extends({}, s, {
        timeParts: timeParts
      });
    });
  }, [setState]);

  if (state.value !== value || state.use12HourClock !== use12HourClock) {
    count++;
    if (count < 100) setState({
      value: value,
      use12HourClock: use12HourClock,
      timeParts: getValueParts(value, use12HourClock)
    });
  }

  return [state.timeParts, setTimeParts];
}

function TimeInput(uncontrolledProps) {
  var _useUncontrollable = (0, _hook.default)(uncontrolledProps, {
    value: 'onChange'
  }),
      value = _useUncontrollable.value,
      use12HourClock = _useUncontrollable.use12HourClock,
      pad = _useUncontrollable.padValues,
      emptyCharacter = _useUncontrollable.emptyCharacter,
      precision = _useUncontrollable.precision,
      noClearButton = _useUncontrollable.noClearButton,
      hoursAddon = _useUncontrollable.hoursAddon,
      _useUncontrollable$mi = _useUncontrollable.minutesAddon,
      minutesAddon = _useUncontrollable$mi === void 0 ? precision === 'seconds' || precision === 'milliseconds' ? ':' : '' : _useUncontrollable$mi,
      _useUncontrollable$se = _useUncontrollable.secondsAddon,
      secondsAddon = _useUncontrollable$se === void 0 ? precision === 'milliseconds' ? '.' : '' : _useUncontrollable$se,
      millisecondsAddon = _useUncontrollable.millisecondsAddon,
      className = _useUncontrollable.className,
      disabled = _useUncontrollable.disabled,
      readOnly = _useUncontrollable.readOnly,
      datePart = _useUncontrollable.datePart,
      onChange = _useUncontrollable.onChange,
      props = _objectWithoutPropertiesLoose(_useUncontrollable, ["value", "use12HourClock", "padValues", "emptyCharacter", "precision", "noClearButton", "hoursAddon", "minutesAddon", "secondsAddon", "millisecondsAddon", "className", "disabled", "readOnly", "datePart", "onChange"]);

  var ref = (0, _react.useRef)();
  var hourRef = (0, _react.useRef)();

  var _useFocusManager = (0, _useFocusManager2.default)(ref, {
    didHandle: function didHandle(focused, e) {
      var _hourRef$current;

      if (!focused) return;
      if (!e.target.dataset.focusable) (_hourRef$current = hourRef.current) === null || _hourRef$current === void 0 ? void 0 : _hourRef$current.focus();else select(e.target);
    }
  }),
      focusEvents = _useFocusManager[0],
      focused = _useFocusManager[1];

  var _useTimePartState = useTimePartState(value, use12HourClock),
      timeParts = _useTimePartState[0],
      setTimeParts = _useTimePartState[1];

  function getDatePart() {
    return _dates.default.startOf(datePart || _dates.default.today(), 'day');
  }

  var getMin = function getMin(part) {
    return part === 'hours' ? 1 : 0;
  };

  var getMax = function getMax(part) {
    if (part === 'hours') return use12HourClock ? 12 : 23;
    if (part === 'milliseconds') return 999;
    return 59;
  };

  function select(target) {
    if (target === void 0) {
      target = document.activeElement;
    }

    window.Promise.resolve().then(function () {
      if (focused) selectTextRange(target);
    });
  }
  /**
   * Handlers
   */


  var useEditableCallback = (0, _interaction.createEditableCallback)(disabled || readOnly, ref);
  var handleClear = useEditableCallback(function () {
    var _hourRef$current2;

    (_hourRef$current2 = hourRef.current) === null || _hourRef$current2 === void 0 ? void 0 : _hourRef$current2.focus();
    if (value) onChange(null);else setTimeParts(getValueParts(null));
  });

  var handleChange = function handleChange(part, event) {
    var _notifyChange;

    var currentValue = timeParts[part];
    var target = event.target;
    var rawValue = target.value;
    var strValue = "" + (currentValue || '') + rawValue;
    var numValue = +strValue;
    select(target);

    if (isNaN(numValue) || strValue && !isValid(strValue, part, use12HourClock)) {
      // the combined value is now past the max or invalid so try the single
      // digit and "start over" filling the value
      if (isValid(rawValue, part, use12HourClock) && !isNaN(+rawValue)) {
        numValue = +rawValue;
      } else {
        return event.preventDefault();
      }
    }

    notifyChange((_notifyChange = {}, _notifyChange[part] = target.value ? numValue : null, _notifyChange));
  };

  var handleSelect = function handleSelect(_ref2) {
    var target = _ref2.target;
    select(target);
  };

  var handleKeyDown = useEditableCallback(function (part, event) {
    var key = event.key,
        input = event.target;
    var start = input.selectionStart,
        end = input.selectionEnd;
    var isMeridiem = part === 'meridiem';

    if (key === 'ArrowUp') {
      event.preventDefault();
      increment(part, 1);
    }

    if (key === 'ArrowDown') {
      event.preventDefault();
      increment(part, -1);
    }

    if (key === 'ArrowLeft' && (isMeridiem || start - 1 < 0)) {
      event.preventDefault();
      focusNext(input, -1);
    }

    if (key === 'ArrowRight' && (isMeridiem || input.value.length <= end + 1)) {
      event.preventDefault();
      focusNext(input, +1);
    }

    if (readOnly && key !== 'Tab') {
      event.preventDefault();
    }

    if (isMeridiem) {
      if (key === 'a' || key === 'A') notifyChange({
        meridiem: 'AM'
      });
      if (key === 'p' || key === 'P') notifyChange({
        meridiem: 'PM'
      });
    }
  });
  var increment = useEditableCallback(function (part, inc) {
    var _notifyChange2;

    var nextPart = timeParts[part];

    if (part === 'meridiem') {
      nextPart = nextPart === 'AM' ? 'PM' : 'AM';
    } else {
      nextPart = (nextPart || 0) + inc;
      if (!isValid(String(nextPart), part, use12HourClock)) return;
    }

    notifyChange((_notifyChange2 = {}, _notifyChange2[part] = nextPart, _notifyChange2));
    select();
  });

  function notifyChange(updates) {
    var nextTimeParts = _extends({}, timeParts, updates);

    if (value && isEmptyValue(nextTimeParts, precision)) {
      return onChange(null);
    }

    if (isPartialValue(nextTimeParts, precision)) return setTimeParts(nextTimeParts);
    var hours = nextTimeParts.hours,
        minutes = nextTimeParts.minutes,
        seconds = nextTimeParts.seconds,
        milliseconds = nextTimeParts.milliseconds,
        meridiem = nextTimeParts.meridiem;
    var nextDate = new Date(value || getDatePart());

    if (use12HourClock) {
      if (hours === 12) hours = 0;
      hours += meridiem === 'PM' ? 12 : 0;
    }

    nextDate.setHours(hours);
    nextDate.setMinutes(minutes);
    if (seconds != null) nextDate.setSeconds(seconds);
    if (milliseconds != null) nextDate.setMilliseconds(milliseconds);
    onChange(nextDate, {
      lastValue: value,
      timeParts: timeParts
    });
  }

  function focusNext(input, delta) {
    var nodes = (0, _querySelectorAll.default)(ref.current, '* [data-focusable="true"]');
    var next = nodes[nodes.indexOf(input) + delta];
    next === null || next === void 0 ? void 0 : next.focus();
    select(next);
  }

  var hours = timeParts.hours,
      minutes = timeParts.minutes,
      seconds = timeParts.seconds,
      milliseconds = timeParts.milliseconds,
      meridiem = timeParts.meridiem;
  var showClear = !isEmptyValue(timeParts, precision);
  return _react.default.createElement(_Widget.default, _extends({}, props, {
    role: "textbox",
    ref: ref
  }, focusEvents, {
    focused: focused,
    disabled: disabled,
    readOnly: readOnly,
    className: (0, _classnames.default)(className, 'rw-input', 'rw-time-input', 'rw-widget-container')
  }), _react.default.createElement(TimePartInput, {
    size: 2,
    pad: pad && 2,
    value: hours,
    disabled: disabled,
    readOnly: readOnly,
    "aria-label": "hours",
    min: getMin('hours'),
    max: getMax('hours'),
    innerRef: hourRef,
    emptyChar: emptyCharacter,
    onSelect: handleSelect,
    onChange: function onChange(e) {
      return handleChange('hours', e);
    },
    onKeyDown: function onKeyDown(e) {
      return handleKeyDown('hours', e);
    }
  }), hoursAddon && _react.default.createElement("span", null, hoursAddon), _react.default.createElement(TimePartInput, {
    size: 2,
    pad: pad && 2,
    value: minutes,
    disabled: disabled,
    readOnly: readOnly,
    "aria-label": "minutes",
    min: getMin('minutes'),
    max: getMax('minutes'),
    emptyChar: emptyCharacter,
    onSelect: handleSelect,
    onChange: function onChange(e) {
      return handleChange('minutes', e);
    },
    onKeyDown: function onKeyDown(e) {
      return handleKeyDown('minutes', e);
    }
  }), minutesAddon && _react.default.createElement("span", null, minutesAddon), (precision === 'seconds' || precision === 'milliseconds') && _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(TimePartInput, {
    size: 2,
    pad: pad && 2,
    value: seconds,
    disabled: disabled,
    readOnly: readOnly,
    "aria-label": "seconds",
    min: getMin('seconds'),
    max: getMax('seconds'),
    emptyChar: emptyCharacter,
    onSelect: handleSelect,
    onChange: function onChange(e) {
      return handleChange('seconds', e);
    },
    onKeyDown: function onKeyDown(e) {
      return handleKeyDown('seconds', e);
    }
  }), secondsAddon && _react.default.createElement("span", null, secondsAddon)), precision === 'milliseconds' && _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(TimePartInput, {
    size: 3,
    pad: pad && 3,
    value: milliseconds,
    disabled: disabled,
    readOnly: readOnly,
    "aria-label": "milliseconds",
    min: getMin('milliseconds'),
    max: getMax('milliseconds'),
    emptyChar: emptyCharacter,
    onSelect: handleSelect,
    onChange: function onChange(e) {
      return handleChange('milliseconds', e);
    },
    onKeyDown: function onKeyDown(e) {
      return handleKeyDown('milliseconds', e);
    }
  }), millisecondsAddon && _react.default.createElement("span", null, millisecondsAddon)), use12HourClock && _react.default.createElement("div", {
    role: "listbox",
    "aria-label": "AM/PM",
    "aria-disabled": disabled,
    "aria-readonly": readOnly,
    onKeyDown: function onKeyDown(e) {
      return handleKeyDown('meridiem', e);
    },
    className: "rw-input-reset rw-time-part-meridiem"
  }, _react.default.createElement("div", {
    "data-focusable": true,
    tabIndex: "0",
    role: "option",
    "aria-atomic": true,
    "aria-selected": true,
    "aria-setsize": "2",
    "aria-live": "assertive",
    "aria-disabled": disabled,
    "aria-readonly": readOnly,
    "aria-posinset": meridiem === 'AM' ? 1 : 2,
    onFocus: handleSelect,
    onSelect: handleSelect
  }, _react.default.createElement("abbr", null, meridiem))), !noClearButton && _react.default.createElement(_Button.default, {
    variant: null,
    label: 'clear input',
    onClick: handleClear,
    className: (0, _classnames.default)('rw-time-input-clear', showClear && 'rw-show')
  }, _Icon.times));
}

TimeInput.propTypes = propTypes;
TimeInput.defaultProps = defaultProps;
var _default = TimeInput;
exports.default = _default;
module.exports = exports["default"];