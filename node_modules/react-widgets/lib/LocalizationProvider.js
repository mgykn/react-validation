"use strict";

exports.__esModule = true;
exports.default = exports.useLocalizer = void 0;

var _react = _interopRequireWildcard(require("react"));

var _messages = require("./messages");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function mergeWithDefaults(date, number, formatOverrides, messages) {
  var _date;

  if (!date && !number) throw new Error('This component requires a Localizer but none was provided');

  if ((_date = date) === null || _date === void 0 ? void 0 : _date.__original) {
    var _date$__original = date.__original;
    date = _date$__original[0];
    number = _date$__original[1];
  }

  number = number || date;
  return {
    messages: (0, _messages.getMessages)(messages),

    get datePropType() {
      return date.propType;
    },

    get numberPropType() {
      return number.propType;
    },

    get firstOfWeek() {
      return date.firstOfWeek;
    },

    formatDate: function formatDate(value, format) {
      return date.formatDate(value, formatOverrides[format] || date.dateFormats[format] || format);
    },
    parseDate: function parseDate(value, format) {
      return date.parseDate(value, formatOverrides[format] || date.dateFormats[format] || format);
    },
    formatNumber: function formatNumber(value, format) {
      return number.formatNumber(value, formatOverrides[format] || number.numberFormats[format] || format);
    },
    parseNumber: number.parseNumber.bind(number),
    decimalChar: number.decimalChar.bind(number),
    precision: number.precision.bind(number),
    __original: [date, number]
  };
}

var LocalizerContext = _react.default.createContext(process.env.NODE_ENV === 'test' && {
  date: global.TEST_LOCALIZER
});

var propTypes = {
  /**
   * A single localizer instance for both date and number localization.
   *
   * @type {Localizer}
   */
  localizer: function localizer() {},

  /**
   * A date-only localizer instance, should be combined with `numberLocalizer` if both are needed.
   *
   * @type {Localizer}
   */
  dateLocalizer: function dateLocalizer() {},

  /**
   * A number-only localizer instance, should be combined with `dateLocalizer` if both are needed.
   *
   * @type {Localizer}
   */
  numberLocalizer: function numberLocalizer() {}
};

var Provider = function Provider(_ref) {
  var localizer = _ref.localizer,
      dateLocalizer = _ref.dateLocalizer,
      numberLocalizer = _ref.numberLocalizer,
      children = _ref.children;
  return _react.default.createElement(LocalizerContext.Provider, {
    value: {
      date: dateLocalizer || localizer,
      number: numberLocalizer
    }
  }, children);
};

Provider.propTypes = propTypes;

var useLocalizer = function useLocalizer(messages, formats) {
  var _ref2 = (0, _react.useContext)(LocalizerContext) || {},
      date = _ref2.date,
      number = _ref2.number;

  return (0, _react.useMemo)(function () {
    return mergeWithDefaults(date, number, formats || {}, messages);
  }, [date, number, formats, messages]);
};

exports.useLocalizer = useLocalizer;
Provider.useLocalizer = useLocalizer;
var _default = Provider;
exports.default = _default;