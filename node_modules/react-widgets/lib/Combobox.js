"use strict";

exports.__esModule = true;
exports.default = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _hook = _interopRequireDefault(require("uncontrollable/hook"));

var _useEventCallback = _interopRequireDefault(require("@restart/hooks/useEventCallback"));

var _Icon = require("./Icon");

var _Input = _interopRequireDefault(require("./Input"));

var _List = _interopRequireDefault(require("./List"));

var _Popup = _interopRequireDefault(require("./Popup"));

var _Select = _interopRequireDefault(require("./Select"));

var _Widget = _interopRequireDefault(require("./Widget"));

var _WidgetPicker = _interopRequireDefault(require("./WidgetPicker"));

var _messages = require("./messages");

var _A11y = require("./util/A11y");

var Filter = _interopRequireWildcard(require("./util/Filter"));

var CustomPropTypes = _interopRequireWildcard(require("./util/PropTypes"));

var _getAccessors = require("./util/getAccessors");

var _hooks = require("./util/hooks");

var _interaction = require("./util/interaction");

var _useFocusManager2 = _interopRequireDefault(require("./util/useFocusManager"));

var _useScrollManager = _interopRequireDefault(require("./util/useScrollManager"));

var _widgetHelpers = require("./util/widgetHelpers");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var propTypes = _extends({}, Filter.propTypes, {
  value: _propTypes.default.any,
  onChange: _propTypes.default.func,
  open: _propTypes.default.bool,
  onToggle: _propTypes.default.func,
  itemComponent: CustomPropTypes.elementType,
  listComponent: CustomPropTypes.elementType,
  groupComponent: CustomPropTypes.elementType,
  groupBy: CustomPropTypes.accessor,
  data: _propTypes.default.array,
  valueField: CustomPropTypes.accessor,
  textField: CustomPropTypes.accessor,
  name: _propTypes.default.string,

  /**
   *
   * @type {(dataItem: ?any, metadata: { originalEvent: SyntheticEvent }) => void}
   */
  onSelect: _propTypes.default.func,
  autoFocus: _propTypes.default.bool,
  disabled: CustomPropTypes.disabled.acceptsArray,
  readOnly: CustomPropTypes.disabled,

  /**
   * When `true` the Combobox will suggest, or fill in, values as you type. The suggestions
   * are always "startsWith", meaning it will search from the start of the `textField` property
   */
  suggest: Filter.propTypes.filter,
  busy: _propTypes.default.bool,

  /** Specify the element used to render the select (down arrow) icon. */
  selectIcon: _propTypes.default.node,

  /** Specify the element used to render the busy indicator */
  busySpinner: _propTypes.default.node,
  delay: _propTypes.default.number,
  dropUp: _propTypes.default.bool,
  popupTransition: CustomPropTypes.elementType,
  placeholder: _propTypes.default.string,

  /** Adds a css class to the input container element. */
  containerClassName: _propTypes.default.string,
  inputProps: _propTypes.default.object,
  listProps: _propTypes.default.object,
  isRtl: _propTypes.default.bool,
  messages: _propTypes.default.shape({
    openCombobox: CustomPropTypes.message,
    emptyList: CustomPropTypes.message,
    emptyFilter: CustomPropTypes.message
  })
});

var defaultProps = {
  data: [],
  defaultValue: '',
  defaultOpen: false,
  filter: true,
  delay: 500,
  selectIcon: _Icon.caretDown,
  listComponent: _List.default
  /**
   * ---
   * shortcuts:
   *   - { key: alt + down arrow, label: open combobox }
   *   - { key: alt + up arrow, label: close combobox }
   *   - { key: down arrow, label: move focus to next item }
   *   - { key: up arrow, label: move focus to previous item }
   *   - { key: home, label: move focus to first item }
   *   - { key: end, label: move focus to last item }
   *   - { key: enter, label: select focused item }
   *   - { key: any key, label: search list for item starting with key }
   * ---
   *
   * Select an item from the list, or input a custom value. The Combobox can also make suggestions as you type.
  
   * @public
   */

};

var Combobox = _react.default.forwardRef(function (uncontrolledProps, outerRef) {
  var _useUncontrollable = (0, _hook.default)(uncontrolledProps, {
    open: 'onToggle',
    value: 'onChange'
  }),
      id = _useUncontrollable.id,
      autoSelectMatches = _useUncontrollable.autoSelectMatches,
      autoFocus = _useUncontrollable.autoFocus,
      textField = _useUncontrollable.textField,
      valueField = _useUncontrollable.valueField,
      open = _useUncontrollable.open,
      value = _useUncontrollable.value,
      filter = _useUncontrollable.filter,
      minLength = _useUncontrollable.minLength,
      caseSensitive = _useUncontrollable.caseSensitive,
      isRtl = _useUncontrollable.isRtl,
      className = _useUncontrollable.className,
      containerClassName = _useUncontrollable.containerClassName,
      placeholder = _useUncontrollable.placeholder,
      busy = _useUncontrollable.busy,
      disabled = _useUncontrollable.disabled,
      readOnly = _useUncontrollable.readOnly,
      selectIcon = _useUncontrollable.selectIcon,
      busySpinner = _useUncontrollable.busySpinner,
      dropUp = _useUncontrollable.dropUp,
      tabIndex = _useUncontrollable.tabIndex,
      popupTransition = _useUncontrollable.popupTransition,
      name = _useUncontrollable.name,
      onSelect = _useUncontrollable.onSelect,
      onChange = _useUncontrollable.onChange,
      onToggle = _useUncontrollable.onToggle,
      onKeyDown = _useUncontrollable.onKeyDown,
      inputProps = _useUncontrollable.inputProps,
      listProps = _useUncontrollable.listProps,
      itemComponent = _useUncontrollable.itemComponent,
      groupComponent = _useUncontrollable.groupComponent,
      optionComponent = _useUncontrollable.optionComponent,
      List = _useUncontrollable.listComponent,
      rawData = _useUncontrollable.data,
      userMessages = _useUncontrollable.messages,
      _ = _useUncontrollable.groupBy,
      elementProps = _objectWithoutPropertiesLoose(_useUncontrollable, ["id", "autoSelectMatches", "autoFocus", "textField", "valueField", "open", "value", "filter", "minLength", "caseSensitive", "isRtl", "className", "containerClassName", "placeholder", "busy", "disabled", "readOnly", "selectIcon", "busySpinner", "dropUp", "tabIndex", "popupTransition", "name", "onSelect", "onChange", "onToggle", "onKeyDown", "inputProps", "listProps", "itemComponent", "groupComponent", "optionComponent", "listComponent", "data", "messages", "groupBy"]);

  var ref = (0, _react.useRef)();
  var inputRef = (0, _react.useRef)();
  var listRef = (0, _react.useRef)();

  var _useState = (0, _react.useState)(null),
      suggestion = _useState[0],
      setSuggestion = _useState[1];

  var shouldFilter = (0, _react.useRef)(false);
  var inputId = (0, _widgetHelpers.useInstanceId)(id, '_input');
  var listId = (0, _widgetHelpers.useInstanceId)(id, '_listbox');
  var activeId = (0, _widgetHelpers.useInstanceId)(id, '_listbox_active_option');
  var accessors = (0, _getAccessors.useAccessors)(textField, valueField);
  var messages = (0, _messages.useMessagesWithDefaults)(userMessages);
  var toggle = (0, _hooks.useDropodownToggle)(open, onToggle);

  var _useFocusManager = (0, _useFocusManager2.default)(ref, uncontrolledProps, {
    didHandle: function didHandle(focused) {
      if (!focused) {
        shouldFilter.current = false;
        toggle.close();
        setSuggestion(null);
        setFocusedItem(null);
      } else {
        focus();
      }
    }
  }),
      focusEvents = _useFocusManager[0],
      focused = _useFocusManager[1];

  var data = (0, _hooks.useFilteredData)(value, rawData, filter, shouldFilter.current ? accessors.text(value) : null, minLength, caseSensitive, accessors.text);
  var selectedItem = (0, _react.useMemo)(function () {
    return data[accessors.indexOf(data, value)];
  }, [data, value, accessors]);
  var list = (0, _hooks.useList)(data, {
    nextProps: uncontrolledProps
  });

  var _useFocusedItem = (0, _hooks.useFocusedItem)(selectedItem, data, list, null),
      focusedItem = _useFocusedItem[0],
      setFocusedItem = _useFocusedItem[1];

  (0, _A11y.useActiveDescendant)(ref, activeId, open, [focusedItem]);
  var isDisabled = disabled === true;
  var isReadOnly = !!readOnly;
  /**
   * Handlers
   */

  var useEditableCallback = (0, _interaction.createEditableCallback)(isDisabled || isReadOnly, ref);
  var handleScroll = (0, _useScrollManager.default)(ref);
  var handleSelect = useEditableCallback(function (data, originalEvent) {
    toggle.close();
    shouldFilter.current = false;
    setSuggestion(null);
    (0, _widgetHelpers.notify)(onSelect, [data, {
      originalEvent: originalEvent
    }]);
    change(data, originalEvent);
    focus();
  });

  var handleInputKeyDown = function handleInputKeyDown(_ref) {
    var key = _ref.key;

    if (key === 'Backspace' || key === 'Delete') {
      setFocusedItem(null);
    }
  };

  var handleInputChange = function handleInputChange(event) {
    var idx = -1;
    if (autoSelectMatches) idx = Filter.indexOf(rawData, {
      minLength: minLength,
      filter: 'eq',
      caseSensitive: false,
      searchTerm: event.target.value,
      textField: accessors.text
    });
    shouldFilter.current = true;
    setSuggestion(null);
    change(idx === -1 ? event.target.value : rawData[idx], event);
    toggle.open();
  };

  var handleKeyDown = useEditableCallback(function (e) {
    var key = e.key,
        altKey = e.altKey,
        shiftKey = e.shiftKey;
    (0, _widgetHelpers.notify)(onKeyDown, [e]);
    if (e.defaultPrevented) return;

    var select = function select(item) {
      return item != null && handleSelect(item, e);
    };

    var setFocused = function setFocused(item) {
      setSuggestion(item);
      setFocusedItem(item);
    };

    if (key === 'End' && open && !shiftKey) {
      e.preventDefault();
      setFocused(list.last());
    } else if (key === 'Home' && open && !shiftKey) {
      e.preventDefault();
      setFocused(list.first());
    } else if (key === 'Escape' && open) {
      e.preventDefault();
      toggle.close();
    } else if (key === 'Enter' && open) {
      e.preventDefault();
      select(focusedItem);
    } else if (key === 'ArrowDown') {
      e.preventDefault();

      if (open) {
        var nextFocusedItem = list.next(focusedItem);
        setFocused(nextFocusedItem === focusedItem ? null : nextFocusedItem);
      } else {
        return toggle.open();
      }
    } else if (key === 'ArrowUp') {
      e.preventDefault();
      if (altKey) return toggle.close();

      if (open) {
        var prevFocusedItem = list.prev(focusedItem);
        setFocused(prevFocusedItem === focusedItem ? null : prevFocusedItem);
      }
    }
  }); // The EventCallback is required b/c Popup blocks updates

  var handleHoverOption = (0, _useEventCallback.default)(function (item) {
    if (!open) return;
    setFocusedItem(item);
  });
  /**
   * Methods
   */

  function focus() {
    var _inputRef$current;

    (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
  }

  function change(nextValue, originalEvent) {
    (0, _widgetHelpers.notify)(onChange, [nextValue, {
      lastValue: value,
      originalEvent: originalEvent
    }]);
  }
  /**
   * Rendering
   */


  (0, _react.useImperativeHandle)(outerRef, function () {
    return {
      focus: focus
    };
  });
  var shouldRenderPopup = (0, _widgetHelpers.useFirstFocusedRender)(focused, open);
  var valueItem = accessors.findOrSelf(data, value);
  var inputValue = accessors.text(suggestion || valueItem);
  var completeType = filter ? 'list' : '';
  return _react.default.createElement(_Widget.default, _extends({}, elementProps, {
    ref: ref,
    open: open,
    isRtl: isRtl,
    dropUp: dropUp,
    focused: focused,
    disabled: isDisabled,
    readOnly: isReadOnly
  }, focusEvents, {
    onKeyDown: handleKeyDown,
    className: (0, _classnames.default)(className, 'rw-combobox')
  }), _react.default.createElement(_WidgetPicker.default, {
    className: containerClassName
  }, _react.default.createElement(_Input.default, _extends({}, inputProps, {
    role: "combobox",
    name: name,
    id: inputId,
    className: (0, _classnames.default)(inputProps === null || inputProps === void 0 ? void 0 : inputProps.className, 'rw-widget-input rw-combobox-input'),
    autoFocus: autoFocus,
    tabIndex: tabIndex,
    disabled: isDisabled,
    readOnly: isReadOnly,
    "aria-busy": !!busy,
    "aria-owns": listId,
    "aria-autocomplete": completeType,
    "aria-expanded": open,
    "aria-haspopup": true,
    placeholder: placeholder,
    value: inputValue,
    onChange: handleInputChange,
    onKeyDown: handleInputKeyDown,
    ref: inputRef
  })), _react.default.createElement(_Select.default, {
    bordered: true,
    busy: busy,
    icon: selectIcon,
    spinner: busySpinner,
    onClick: toggle,
    disabled: disabled || readOnly // FIXME
    ,
    label: messages.openCombobox(uncontrolledProps)
  })), shouldRenderPopup && _react.default.createElement(_Popup.default, {
    open: open,
    dropUp: dropUp,
    transition: popupTransition,
    onEntering: function onEntering() {
      var _listRef$current;

      return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.forceUpdate();
    }
  }, _react.default.createElement(List, _extends({}, listProps, {
    id: listId,
    activeId: activeId,
    data: data,
    dataState: list.dataState,
    isDisabled: list.isDisabled,
    textAccessor: accessors.text,
    valueAccessor: accessors.value,
    itemComponent: itemComponent,
    groupComponent: groupComponent,
    optionComponent: optionComponent,
    selectedItem: selectedItem,
    focusedItem: open ? focusedItem : null,
    searchTerm: accessors.text(value) || '',
    "aria-hidden": !open,
    "aria-labelledby": inputId,
    "aria-live": open && 'polite',
    onSelect: handleSelect,
    onHoverOption: handleHoverOption,
    onMove: handleScroll,
    ref: listRef,
    messages: {
      emptyList: rawData.length ? messages.emptyFilter : messages.emptyList
    }
  }))));
});

Combobox.displayName = 'Combobox';
Combobox.propTypes = propTypes;
Combobox.defaultProps = defaultProps;
var _default = Combobox;
exports.default = _default;
module.exports = exports["default"];