"use strict";

exports.__esModule = true;
exports.default = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _hook = _interopRequireDefault(require("uncontrollable/hook"));

var _useEventCallback = _interopRequireDefault(require("@restart/hooks/useEventCallback"));

var _useTimeout = _interopRequireDefault(require("@restart/hooks/useTimeout"));

var _AddToListOption = _interopRequireDefault(require("./AddToListOption"));

var _DropdownListInput = _interopRequireDefault(require("./DropdownListInput"));

var _Icon = require("./Icon");

var _List = _interopRequireDefault(require("./List"));

var _Popup = _interopRequireDefault(require("./Popup"));

var _Select = _interopRequireDefault(require("./Select"));

var _Widget = _interopRequireDefault(require("./Widget"));

var _WidgetPicker = _interopRequireDefault(require("./WidgetPicker"));

var _messages = require("./messages");

var _A11y = require("./util/A11y");

var Filter = _interopRequireWildcard(require("./util/Filter"));

var CustomPropTypes = _interopRequireWildcard(require("./util/PropTypes"));

var _canShowCreate = _interopRequireDefault(require("./util/canShowCreate"));

var _dataHelpers = require("./util/dataHelpers");

var _getAccessors = require("./util/getAccessors");

var _hooks = require("./util/hooks");

var _interaction = require("./util/interaction");

var _useFocusManager2 = _interopRequireDefault(require("./util/useFocusManager"));

var _useScrollManager = _interopRequireDefault(require("./util/useScrollManager"));

var _widgetHelpers = require("./util/widgetHelpers");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var propTypes = _extends({}, Filter.propTypes, {
  value: _propTypes.default.any,

  /**
   * @type {function (
   *  dataItems: ?any,
   *  metadata: {
   *    lastValue: ?any,
   *    searchTerm: ?string
   *    originalEvent: SyntheticEvent,
   *  }
   * ): void}
   */
  onChange: _propTypes.default.func,
  open: _propTypes.default.bool,
  onToggle: _propTypes.default.func,
  data: _propTypes.default.array,
  valueField: CustomPropTypes.accessor,
  textField: CustomPropTypes.accessor,
  allowCreate: _propTypes.default.oneOf([true, false, 'onFilter']),

  /**
   * A React component for customizing the rendering of the DropdownList
   * value
   */
  valueComponent: CustomPropTypes.elementType,
  itemComponent: CustomPropTypes.elementType,
  listComponent: CustomPropTypes.elementType,
  optionComponent: CustomPropTypes.elementType,
  groupComponent: CustomPropTypes.elementType,
  groupBy: CustomPropTypes.accessor,

  /**
   *
   * @type {(dataItem: ?any, metadata: { originalEvent: SyntheticEvent }) => void}
   */
  onSelect: _propTypes.default.func,
  onCreate: _propTypes.default.func,

  /**
   * @type function(searchTerm: string, metadata: { action, lastSearchTerm, originalEvent? })
   */
  onSearch: _propTypes.default.func,
  searchTerm: _propTypes.default.string,
  busy: _propTypes.default.bool,

  /** Specify the element used to render the select (down arrow) icon. */
  selectIcon: _propTypes.default.node,

  /** Specify the element used to render the busy indicator */
  busySpinner: _propTypes.default.node,
  placeholder: _propTypes.default.string,
  dropUp: _propTypes.default.bool,
  popupTransition: CustomPropTypes.elementType,
  disabled: CustomPropTypes.disabled.acceptsArray,
  readOnly: CustomPropTypes.disabled,

  /** Adds a css class to the input container element. */
  containerClassName: _propTypes.default.string,
  inputProps: _propTypes.default.object,
  listProps: _propTypes.default.object,
  isRtl: _propTypes.default.bool,
  messages: _propTypes.default.shape({
    open: _propTypes.default.string,
    emptyList: CustomPropTypes.message,
    emptyFilter: CustomPropTypes.message,
    filterPlaceholder: _propTypes.default.string,
    createOption: CustomPropTypes.message
  })
});

var defaultProps = {
  data: [],
  delay: 500,
  defaultSearchTerm: '',
  allowCreate: false,
  selectIcon: _Icon.caretDown,
  listComponent: _List.default
};

function useSearchWordBuilder(delay) {
  var timeout = (0, _useTimeout.default)();
  var wordRef = (0, _react.useRef)('');

  function search(character, cb) {
    var word = (wordRef.current + character).toLowerCase();
    if (!character) return;
    wordRef.current = word;
    timeout.set(function () {
      wordRef.current = '';
      cb(word);
    }, delay);
  }

  return search;
}
/**
 * ---
 * shortcuts:
 *   - { key: alt + down arrow, label: open dropdown }
 *   - { key: alt + up arrow, label: close dropdown }
 *   - { key: down arrow, label: move focus to next item }
 *   - { key: up arrow, label: move focus to previous item }
 *   - { key: home, label: move focus to first item }
 *   - { key: end, label: move focus to last item }
 *   - { key: enter, label: select focused item }
 *   - { key: ctrl + enter, label: create new option from current searchTerm }
 *   - { key: any key, label: search list for item starting with key }
 * ---
 *
 * A `<select>` replacement for single value lists.
 * @public
 */


var DropdownList = _react.default.forwardRef(function (uncontrolledProps, outerRef) {
  var _extends2;

  var _useUncontrollable = (0, _hook.default)(uncontrolledProps, {
    open: 'onToggle',
    value: 'onChange',
    searchTerm: 'onSearch'
  }),
      id = _useUncontrollable.id,
      autoFocus = _useUncontrollable.autoFocus,
      textField = _useUncontrollable.textField,
      valueField = _useUncontrollable.valueField,
      open = _useUncontrollable.open,
      value = _useUncontrollable.value,
      searchTerm = _useUncontrollable.searchTerm,
      filter = _useUncontrollable.filter,
      minLength = _useUncontrollable.minLength,
      allowCreate = _useUncontrollable.allowCreate,
      caseSensitive = _useUncontrollable.caseSensitive,
      isRtl = _useUncontrollable.isRtl,
      className = _useUncontrollable.className,
      containerClassName = _useUncontrollable.containerClassName,
      placeholder = _useUncontrollable.placeholder,
      busy = _useUncontrollable.busy,
      disabled = _useUncontrollable.disabled,
      readOnly = _useUncontrollable.readOnly,
      selectIcon = _useUncontrollable.selectIcon,
      busySpinner = _useUncontrollable.busySpinner,
      dropUp = _useUncontrollable.dropUp,
      tabIndex = _useUncontrollable.tabIndex,
      popupTransition = _useUncontrollable.popupTransition,
      name = _useUncontrollable.name,
      autoComplete = _useUncontrollable.autoComplete,
      onSelect = _useUncontrollable.onSelect,
      onCreate = _useUncontrollable.onCreate,
      onChange = _useUncontrollable.onChange,
      onToggle = _useUncontrollable.onToggle,
      onKeyPress = _useUncontrollable.onKeyPress,
      onKeyDown = _useUncontrollable.onKeyDown,
      onSearch = _useUncontrollable.onSearch,
      onClick = _useUncontrollable.onClick,
      inputProps = _useUncontrollable.inputProps,
      listProps = _useUncontrollable.listProps,
      itemComponent = _useUncontrollable.itemComponent,
      groupComponent = _useUncontrollable.groupComponent,
      optionComponent = _useUncontrollable.optionComponent,
      valueComponent = _useUncontrollable.valueComponent,
      List = _useUncontrollable.listComponent,
      rawData = _useUncontrollable.data,
      userMessages = _useUncontrollable.messages,
      _ = _useUncontrollable.groupBy,
      elementProps = _objectWithoutPropertiesLoose(_useUncontrollable, ["id", "autoFocus", "textField", "valueField", "open", "value", "searchTerm", "filter", "minLength", "allowCreate", "caseSensitive", "isRtl", "className", "containerClassName", "placeholder", "busy", "disabled", "readOnly", "selectIcon", "busySpinner", "dropUp", "tabIndex", "popupTransition", "name", "autoComplete", "onSelect", "onCreate", "onChange", "onToggle", "onKeyPress", "onKeyDown", "onSearch", "onClick", "inputProps", "listProps", "itemComponent", "groupComponent", "optionComponent", "valueComponent", "listComponent", "data", "messages", "groupBy"]);

  var ref = (0, _react.useRef)();
  var filterRef = (0, _react.useRef)();
  var listRef = (0, _react.useRef)();
  var inputId = (0, _widgetHelpers.useInstanceId)(id, '_input');
  var listId = (0, _widgetHelpers.useInstanceId)(id, '_listbox');
  var createId = (0, _widgetHelpers.useInstanceId)(id, '_create_option');
  var activeId = (0, _widgetHelpers.useInstanceId)(id, '_listbox_active_option');
  var accessors = (0, _getAccessors.useAccessors)(textField, valueField);
  var messages = (0, _messages.useMessagesWithDefaults)(userMessages);
  (0, _hooks.useAutoFocus)(autoFocus, ref);
  var toggle = (0, _hooks.useDropodownToggle)(open, onToggle);
  var handleScroll = (0, _useScrollManager.default)(ref);

  var _useFocusManager = (0, _useFocusManager2.default)(ref, uncontrolledProps, {
    didHandle: function didHandle(focused) {
      if (focused) {
        if (filter) focus();
        return;
      }

      toggle.close();
      clearSearch();
    }
  }),
      focusEvents = _useFocusManager[0],
      focused = _useFocusManager[1];

  var data = (0, _hooks.useFilteredData)(value, rawData, open ? filter : false, searchTerm, minLength, caseSensitive, accessors.text);
  var list = (0, _hooks.useList)(data, {
    nextProps: uncontrolledProps
  }); // TODO: shouldn't this just be `data[accessors.indexOf(data, value)]`

  var selectedItem = (0, _react.useMemo)(function () {
    return list.nextEnabled(data[accessors.indexOf(data, value)]);
  }, [data, value, accessors]);

  var _useFocusedItem = (0, _hooks.useFocusedItem)(selectedItem, data, list),
      focusedItem = _useFocusedItem[0],
      setFocusedItem = _useFocusedItem[1];

  var _useState = (0, _react.useState)(false),
      autofilling = _useState[0],
      setAutofilling = _useState[1];

  var nextSearchChar = useSearchWordBuilder(data);
  (0, _A11y.useActiveDescendant)(ref, activeId, open, [focusedItem]);
  var isDisabled = disabled === true;
  var isReadOnly = !!readOnly;
  var showCreateOption = (0, _canShowCreate.default)(allowCreate, {
    searchTerm: searchTerm,
    caseSensitive: caseSensitive,
    data: data,
    accessors: accessors
  });
  var useEditableCallback = (0, _interaction.createEditableCallback)(isDisabled || isReadOnly, ref);
  var handleCreate = useEditableCallback(function (searchTerm, event) {
    if (searchTerm === void 0) {
      searchTerm = '';
    }

    (0, _widgetHelpers.notify)(onCreate, searchTerm);
    clearSearch(event);
    toggle.close();
    focus(ref);
  });
  var handleSelect = useEditableCallback(function (dataItem, originalEvent) {
    if (dataItem === undefined || dataItem === _hooks.CREATE_OPTION) {
      handleCreate(searchTerm);
      return;
    }

    (0, _widgetHelpers.notify)(onSelect, [dataItem, {
      originalEvent: originalEvent
    }]);
    change(dataItem, originalEvent);
    toggle.close();
    focus(ref);
  });
  var handleClick = useEditableCallback(function (e) {
    focus();
    toggle();
    (0, _widgetHelpers.notify)(onClick, e);
  });
  var handleKeyDown = useEditableCallback(function (e) {
    var key = e.key,
        altKey = e.altKey,
        ctrlKey = e.ctrlKey,
        shiftKey = e.shiftKey;
    var createIsFocused = focusedItem === _hooks.CREATE_OPTION;
    (0, _widgetHelpers.notify)(onKeyDown, [e]);

    var closeWithFocus = function closeWithFocus() {
      clearSearch();
      toggle.close();
      if (open) setTimeout(focus);
    };

    if (e.defaultPrevented) return;

    if (key === 'End' && open && !shiftKey) {
      e.preventDefault();
      setFocusedItem(list.last());
    } else if (key === 'Home' && open && !shiftKey) {
      e.preventDefault();
      setFocusedItem(list.first());
    } else if (key === 'Escape' && (open || searchTerm)) {
      e.preventDefault();
      closeWithFocus();
    } else if (key === 'Enter' && open && ctrlKey && showCreateOption) {
      e.preventDefault();
      handleCreate(searchTerm, e);
    } else if ((key === 'Enter' || key === ' ' && !filter) && open) {
      e.preventDefault();
      handleSelect(focusedItem, e);
    } else if (key === 'ArrowDown') {
      e.preventDefault();

      if (!open) {
        toggle.open();
        return;
      }

      var next = list.next(focusedItem);
      var creating = createIsFocused || showCreateOption && focusedItem === next;
      setFocusedItem(creating ? _hooks.CREATE_OPTION : next);
    } else if (key === 'ArrowUp') {
      e.preventDefault();
      if (altKey) return closeWithFocus();
      setFocusedItem(createIsFocused ? list.last() : list.prev(focusedItem));
    }
  });
  var handleKeyPress = useEditableCallback(function (e) {
    (0, _widgetHelpers.notify)(onKeyPress, [e]);
    if (e.defaultPrevented || filter) return;
    nextSearchChar(String.fromCharCode(e.which), function (word) {
      var startItem = open ? focusedItem : selectedItem;
      var item = list.next(startItem, word);

      if (item === startItem) {
        item = list.next(null, word);
      }

      if (!item) return;
      if (open) setFocusedItem(item);else change(item, e);
    });
  });

  var handleInputChange = function handleInputChange(e) {
    // hitting space to open
    if (!open && !e.target.value.trim()) {
      e.preventDefault();
    } else {
      search(e.target.value, e, 'input');
    }

    toggle.open();
  };

  var handleAutofillChange = function handleAutofillChange(e) {
    var filledValue = e.target.value.toLowerCase();
    if (filledValue === '') return void change(null);

    for (var _iterator = rawData, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var item = _ref;

      var _value = (0, _dataHelpers.dataValue)(item, textField);

      if (String(_value).toLowerCase() === filledValue || (0, _dataHelpers.dataText)(item).toLowerCase() === filledValue) {
        change(item, e);
        break;
      }
    }
  }; // The EventCallback is required b/c Popup blocks updates


  var handleHoverOption = (0, _useEventCallback.default)(function (item) {
    if (!open) return;
    setFocusedItem(item);
  });

  function change(nextValue, originalEvent) {
    if (!accessors.matches(nextValue, value)) {
      (0, _widgetHelpers.notify)(onChange, [nextValue, {
        searchTerm: searchTerm,
        originalEvent: originalEvent,
        lastValue: value
      }]);
      clearSearch(originalEvent);
      toggle.close();
    }
  }

  function focus() {
    if (filter) filterRef.current.focus();else ref.current.focus();
  }

  function clearSearch(originalEvent) {
    search('', originalEvent, 'clear');
  }

  function search(nextSearchTerm, originalEvent, action) {
    if (action === void 0) {
      action = 'input';
    }

    if (searchTerm !== nextSearchTerm) (0, _widgetHelpers.notify)(onSearch, [nextSearchTerm, {
      action: action,
      originalEvent: originalEvent,
      lastSearchTerm: searchTerm
    }]);
  }
  /**
   * Render
   */


  (0, _react.useImperativeHandle)(outerRef, function () {
    return {
      focus: focus
    };
  });
  var valueItem = accessors.findOrSelf(data, value);
  var shouldRenderPopup = (0, _widgetHelpers.useFirstFocusedRender)(focused, open);

  var widgetProps = _extends(elementProps, {
    name: undefined,
    role: 'combobox',
    id: inputId,
    tabIndex: open && filter ? -1 : tabIndex || 0,
    'aria-owns': listId,
    'aria-activedescendant': open ? activeId : null,
    'aria-expanded': !!open,
    'aria-haspopup': true,
    'aria-busy': !!busy,
    'aria-live': !open && 'polite',
    'aria-autocomplete': 'list',
    'aria-disabled': isDisabled,
    'aria-readonly': isReadOnly
  });

  return _react.default.createElement(_Widget.default, _extends({}, widgetProps, {
    open: open,
    isRtl: isRtl,
    dropUp: dropUp,
    focused: focused,
    disabled: isDisabled,
    readOnly: isReadOnly,
    autofilling: autofilling
  }, focusEvents, {
    onKeyDown: handleKeyDown,
    onKeyPress: handleKeyPress,
    className: (0, _classnames.default)(className, 'rw-dropdown-list'),
    ref: ref
  }), _react.default.createElement(_WidgetPicker.default, {
    onClick: handleClick,
    className: (0, _classnames.default)(containerClassName, 'rw-widget-input')
  }, _react.default.createElement(_DropdownListInput.default, _extends({}, inputProps, (_extends2 = {
    value: valueItem,
    textField: textField,
    name: name,
    allowSearch: !!filter,
    searchTerm: searchTerm,
    onSearch: onSearch,
    ref: filterRef,
    autoComplete: autoComplete
  }, _extends2["onSearch"] = handleInputChange, _extends2.onAutofill = setAutofilling, _extends2.onAutofillChange = handleAutofillChange, _extends2.placeholder = placeholder, _extends2.valueComponent = valueComponent, _extends2))), _react.default.createElement(_Select.default, {
    busy: busy,
    icon: selectIcon,
    spinner: busySpinner,
    role: "presentational",
    "aria-hidden": "true",
    disabled: isDisabled || isReadOnly,
    label: messages.openDropdown(uncontrolledProps)
  })), shouldRenderPopup && _react.default.createElement(_Popup.default, {
    open: open,
    dropUp: dropUp,
    transition: popupTransition,
    onEntered: focus,
    onEntering: function onEntering() {
      return listRef.current.forceUpdate();
    }
  }, _react.default.createElement(List, _extends({}, listProps, {
    id: listId,
    activeId: activeId,
    data: data,
    dataState: list.dataState,
    isDisabled: list.isDisabled,
    searchTerm: searchTerm,
    textAccessor: accessors.text,
    valueAccessor: accessors.value,
    itemComponent: itemComponent,
    groupComponent: groupComponent,
    optionComponent: optionComponent,
    selectedItem: selectedItem,
    focusedItem: open ? focusedItem : null,
    onSelect: handleSelect,
    onMove: handleScroll,
    onHoverOption: handleHoverOption,
    "aria-live": open && 'polite',
    "aria-labelledby": inputId,
    "aria-hidden": !open,
    ref: listRef,
    messages: {
      emptyList: rawData.length ? messages.emptyFilter : messages.emptyList
    }
  })), showCreateOption && _react.default.createElement(_AddToListOption.default, {
    id: createId,
    searchTerm: searchTerm,
    onSelect: handleCreate,
    focused: !focusedItem || focusedItem === _hooks.CREATE_OPTION
  }, messages.createOption(value, searchTerm))));
});

DropdownList.displayName = 'DropdownList';
DropdownList.propTypes = propTypes;
DropdownList.defaultProps = defaultProps;
var _default = DropdownList;
exports.default = _default;
module.exports = exports["default"];