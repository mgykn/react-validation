"use strict";

exports.__esModule = true;
exports.default = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _closest = _interopRequireDefault(require("dom-helpers/query/closest"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _hook = _interopRequireDefault(require("uncontrollable/hook"));

var _useEventCallback = _interopRequireDefault(require("@restart/hooks/useEventCallback"));

var _AddToListOption = _interopRequireDefault(require("./AddToListOption"));

var _Icon = require("./Icon");

var _List = _interopRequireDefault(require("./List"));

var _MultiselectInput = _interopRequireDefault(require("./MultiselectInput"));

var _MultiselectTagList = _interopRequireDefault(require("./MultiselectTagList"));

var _Popup = _interopRequireDefault(require("./Popup"));

var _Select = _interopRequireDefault(require("./Select"));

var _Widget = _interopRequireDefault(require("./Widget"));

var _WidgetPicker = _interopRequireDefault(require("./WidgetPicker"));

var _messages = require("./messages");

var _A11y = require("./util/A11y");

var Filter = _interopRequireWildcard(require("./util/Filter"));

var CustomPropTypes = _interopRequireWildcard(require("./util/PropTypes"));

var _canShowCreate = _interopRequireDefault(require("./util/canShowCreate"));

var _getAccessors = require("./util/getAccessors");

var _hooks = require("./util/hooks");

var _interaction = require("./util/interaction");

var _reduceToListState = require("./util/reduceToListState");

var _useFocusManager2 = _interopRequireDefault(require("./util/useFocusManager"));

var _useScrollManager = _interopRequireDefault(require("./util/useScrollManager"));

var _widgetHelpers = require("./util/widgetHelpers");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var ENTER = 13;
var INSERT = 'insert';
var REMOVE = 'remove';

var propTypes = _extends({}, Filter.propTypes, {
  data: _propTypes.default.array,
  //-- controlled props --
  value: _propTypes.default.array,

  /**
   * @type {function (
   *  dataItems: ?any[],
   *  metadata: {
   *    dataItem: any,
   *    action: 'insert' | 'remove',
   *    originalEvent: SyntheticEvent,
   *    lastValue: ?any[],
   *    searchTerm: ?string
   *  }
   * ): void}
   */
  onChange: _propTypes.default.func,
  searchTerm: _propTypes.default.string,

  /**
   * @type {function (
   *  searchTerm: ?string,
   *  metadata: {
   *    action: 'clear' | 'input',
   *    lastSearchTerm: ?string,
   *    originalEvent: SyntheticEvent,
   *  }
   * ): void}
   */
  onSearch: _propTypes.default.func,
  open: _propTypes.default.bool,
  onToggle: _propTypes.default.func,
  //-------------------------------------------
  valueField: CustomPropTypes.accessor,
  textField: CustomPropTypes.accessor,
  tagComponent: CustomPropTypes.elementType,

  /**
   * Control the rendering of the outer tag component, including the delete button. To control just hte tag label, `use tagComponent` instead
   */
  tagOptionComponent: CustomPropTypes.elementType,
  itemComponent: CustomPropTypes.elementType,
  listComponent: CustomPropTypes.elementType,
  groupComponent: CustomPropTypes.elementType,
  groupBy: CustomPropTypes.accessor,
  allowCreate: _propTypes.default.oneOf([true, false, 'onFilter']),

  /**
   *
   * @type { (dataItem: ?any, metadata: { originalEvent: SyntheticEvent }) => void }
   */
  onSelect: _propTypes.default.func,

  /**
   * @type { (searchTerm: string) => void }
   */
  onCreate: _propTypes.default.func,
  busy: _propTypes.default.bool,

  /** Specify the element used to render the select (down arrow) icon. */
  selectIcon: _propTypes.default.node,

  /** Specify the element used to render tag clear icons. */
  clearTagIcon: _propTypes.default.node,

  /** Specify the element used to render the busy indicator */
  busySpinner: _propTypes.default.node,
  dropUp: _propTypes.default.bool,
  popupTransition: CustomPropTypes.elementType,

  /** Adds a css class to the input container element. */
  containerClassName: _propTypes.default.string,
  inputProps: _propTypes.default.object,
  listProps: _propTypes.default.object,
  autoFocus: _propTypes.default.bool,
  placeholder: _propTypes.default.string,

  /** Continue to show the input placeholder even if tags are selected */
  showPlaceholderWithValues: _propTypes.default.bool,
  disabled: CustomPropTypes.disabled.acceptsArray,
  readOnly: CustomPropTypes.disabled,
  isRtl: _propTypes.default.bool,
  messages: _propTypes.default.shape({
    open: CustomPropTypes.message,
    emptyList: CustomPropTypes.message,
    emptyFilter: CustomPropTypes.message,
    createOption: CustomPropTypes.message,
    tagsLabel: CustomPropTypes.message,
    selectedItems: CustomPropTypes.message,
    noneSelected: CustomPropTypes.message,
    removeLabel: CustomPropTypes.message
  })
});

var defaultProps = {
  data: [],
  allowCreate: false,
  filter: 'startsWith',
  defaultValue: [],
  defaultSearchTerm: '',
  clearTagIcon: _Icon.times,
  selectIcon: _Icon.caretDown,
  listComponent: _List.default,
  showPlaceholderWithValues: false
};
var EMPTY_ARRAY = [];

function useMultiselectData(value, data, filter, searchTerm, minLength, caseSensitive, accessors) {
  if (value === void 0) {
    value = EMPTY_ARRAY;
  }

  data = (0, _react.useMemo)(function () {
    return data.filter(function (i) {
      return !value.some(function (v) {
        return accessors.matches(i, v);
      });
    });
  }, [data, value, accessors]);
  return [(0, _hooks.useFilteredData)(value, data, filter, searchTerm, minLength, caseSensitive, accessors.text), data.length];
}
/**
 * ---
 * shortcuts:
 *   - { key: left arrow, label: move focus to previous tag }
 *   - { key: right arrow, label: move focus to next tag }
 *   - { key: delete, deselect focused tag }
 *   - { key: backspace, deselect next tag }
 *   - { key: alt + up arrow, label: close Multiselect }
 *   - { key: down arrow, label: open Multiselect, and move focus to next item }
 *   - { key: up arrow, label: move focus to previous item }
 *   - { key: home, label: move focus to first item }
 *   - { key: end, label: move focus to last item }
 *   - { key: enter, label: select focused item }
 *   - { key: ctrl + enter, label: create new tag from current searchTerm }
 *   - { key: any key, label: search list for item starting with key }
 * ---
 *
 * A select listbox alternative.
 *
 * @public
 */


var Multiselect = _react.default.forwardRef(function (uncontrolledProps, outerRef) {
  var _useUncontrollable = (0, _hook.default)(uncontrolledProps, {
    open: 'onToggle',
    value: 'onChange',
    searchTerm: 'onSearch'
  }),
      id = _useUncontrollable.id,
      autoFocus = _useUncontrollable.autoFocus,
      textField = _useUncontrollable.textField,
      valueField = _useUncontrollable.valueField,
      open = _useUncontrollable.open,
      rawValue = _useUncontrollable.value,
      searchTerm = _useUncontrollable.searchTerm,
      filter = _useUncontrollable.filter,
      maxLength = _useUncontrollable.maxLength,
      minLength = _useUncontrollable.minLength,
      allowCreate = _useUncontrollable.allowCreate,
      caseSensitive = _useUncontrollable.caseSensitive,
      isRtl = _useUncontrollable.isRtl,
      className = _useUncontrollable.className,
      containerClassName = _useUncontrollable.containerClassName,
      placeholder = _useUncontrollable.placeholder,
      busy = _useUncontrollable.busy,
      disabled = _useUncontrollable.disabled,
      readOnly = _useUncontrollable.readOnly,
      selectIcon = _useUncontrollable.selectIcon,
      clearTagIcon = _useUncontrollable.clearTagIcon,
      busySpinner = _useUncontrollable.busySpinner,
      dropUp = _useUncontrollable.dropUp,
      tabIndex = _useUncontrollable.tabIndex,
      popupTransition = _useUncontrollable.popupTransition,
      showPlaceholderWithValues = _useUncontrollable.showPlaceholderWithValues,
      onSelect = _useUncontrollable.onSelect,
      onCreate = _useUncontrollable.onCreate,
      onChange = _useUncontrollable.onChange,
      onToggle = _useUncontrollable.onToggle,
      onKeyDown = _useUncontrollable.onKeyDown,
      onSearch = _useUncontrollable.onSearch,
      inputProps = _useUncontrollable.inputProps,
      listProps = _useUncontrollable.listProps,
      itemComponent = _useUncontrollable.itemComponent,
      groupComponent = _useUncontrollable.groupComponent,
      optionComponent = _useUncontrollable.optionComponent,
      tagComponent = _useUncontrollable.tagComponent,
      tagOptionComponent = _useUncontrollable.tagOptionComponent,
      List = _useUncontrollable.listComponent,
      rawData = _useUncontrollable.data,
      userMessages = _useUncontrollable.messages,
      _ = _useUncontrollable.groupBy,
      elementProps = _objectWithoutPropertiesLoose(_useUncontrollable, ["id", "autoFocus", "textField", "valueField", "open", "value", "searchTerm", "filter", "maxLength", "minLength", "allowCreate", "caseSensitive", "isRtl", "className", "containerClassName", "placeholder", "busy", "disabled", "readOnly", "selectIcon", "clearTagIcon", "busySpinner", "dropUp", "tabIndex", "popupTransition", "showPlaceholderWithValues", "onSelect", "onCreate", "onChange", "onToggle", "onKeyDown", "onSearch", "inputProps", "listProps", "itemComponent", "groupComponent", "optionComponent", "tagComponent", "tagOptionComponent", "listComponent", "data", "messages", "groupBy"]);

  var ref = (0, _react.useRef)();
  var inputRef = (0, _react.useRef)();
  var tagsRef = (0, _react.useRef)();
  var listRef = (0, _react.useRef)();
  var inputId = (0, _widgetHelpers.useInstanceId)(id, '_input');
  var tagsId = (0, _widgetHelpers.useInstanceId)(id, '_taglist');
  var notifyId = (0, _widgetHelpers.useInstanceId)(id, '_notify_area');
  var listId = (0, _widgetHelpers.useInstanceId)(id, '_listbox');
  var createId = (0, _widgetHelpers.useInstanceId)(id, '_createlist_option');
  var activeTagId = (0, _widgetHelpers.useInstanceId)(id, '_taglist_active_tag');
  var activeOptionId = (0, _widgetHelpers.useInstanceId)(id, '_listbox_active_option');
  var accessors = (0, _getAccessors.useAccessors)(textField, valueField);
  var messages = (0, _messages.useMessagesWithDefaults)(userMessages);
  var toggle = (0, _hooks.useDropodownToggle)(open, onToggle);

  var _useFocusManager = (0, _useFocusManager2.default)(ref, uncontrolledProps, {
    didHandle: function didHandle(focused) {
      if (focused) return focus();
      toggle.close();
      clearSearch();
      if (tagsRef.current) setFocusedTag(null);
    }
  }),
      focusEvents = _useFocusManager[0],
      focused = _useFocusManager[1]; // TODO: don't cover this?


  var value = rawValue || EMPTY_ARRAY;
  var dataItems = (0, _react.useMemo)(function () {
    return value.map(function (item) {
      return accessors.findOrSelf(rawData, item);
    });
  }, [rawData, value, accessors]);

  var _useMultiselectData = useMultiselectData(value, rawData, open ? filter : false, searchTerm, minLength, caseSensitive, accessors),
      data = _useMultiselectData[0],
      lengthWithoutValues = _useMultiselectData[1];

  var list = (0, _hooks.useList)(data, {
    nextProps: uncontrolledProps
  });
  var tagList = (0, _hooks.useList)(dataItems, {
    nextProps: uncontrolledProps,
    getDataState: _reduceToListState.defaultGetDataState
  });

  var _useFocusedItem = (0, _hooks.useFocusedItem)(value, data, list),
      focusedItem = _useFocusedItem[0],
      setFocusedItem = _useFocusedItem[1];

  var _useFocusedItem2 = (0, _hooks.useFocusedItem)(value, dataItems, list, null),
      focusedTag = _useFocusedItem2[0],
      setFocusedTag = _useFocusedItem2[1];

  var showCreateOption = (0, _canShowCreate.default)(allowCreate, {
    searchTerm: searchTerm,
    caseSensitive: caseSensitive,
    data: data,
    dataItems: dataItems,
    accessors: accessors
  });
  var isDisabled = disabled === true;
  var isReadOnly = !!readOnly;
  /**
   * Update aria when it changes on update
   */

  (0, _react.useEffect)(function () {
    var active;
    if (!open) active = focusedTag ? activeTagId : '';else if (focusedItem || showCreateOption) active = activeOptionId;
    (0, _A11y.setActiveDescendant)(inputRef.current, active, open);
  }, [open, focusedItem]);
  /**
   * Event Handlers
   */

  var useEditableCallback = (0, _interaction.createEditableCallback)(isDisabled || isReadOnly, ref);
  var handleScroll = (0, _useScrollManager.default)(ref);

  var handleDelete = function handleDelete(dataItem, event) {
    if (isDisabled || readOnly) return;
    focus();
    change(dataItem, event, REMOVE);
  };

  var deletingRef = (0, _react.useRef)(false);

  var handleSearchKeyDown = function handleSearchKeyDown(e) {
    if (e.key === 'Backspace' && e.target.value && !deletingRef.current) deletingRef.current = true;
  };

  var handleSearchKeyUp = function handleSearchKeyUp(e) {
    if (e.key === 'Backspace' && deletingRef.current) {
      deletingRef.current = false;
    }
  };

  var handleInputChange = function handleInputChange(e) {
    search(e.target.value, e, 'input');
    toggle.open();
  };

  var handleClick = useEditableCallback(function (_ref) {
    var target = _ref.target;
    focus();

    if ((0, _closest.default)(target, '.rw-select') && open) {
      toggle.close();
    } else toggle.open();
  });
  var handleDoubleClick = useEditableCallback(function () {
    var _inputRef$current;

    if (!inputRef.current) return;
    focus();
    (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.select();
  });
  var handleSelect = useEditableCallback(function (dataItem, originalEvent) {
    if (dataItem === undefined || dataItem === _hooks.CREATE_OPTION) {
      handleCreate(searchTerm, originalEvent);
      return;
    }

    (0, _widgetHelpers.notify)(onSelect, [dataItem, {
      originalEvent: originalEvent
    }]);
    change(dataItem, originalEvent, INSERT);
    focus();
  });
  var handleCreate = useEditableCallback(function (searchTerm, event) {
    if (searchTerm === void 0) {
      searchTerm = '';
    }

    (0, _widgetHelpers.notify)(onCreate, searchTerm);
    clearSearch(event);
    focus();
  });
  var handleKeyDown = useEditableCallback(function (event) {
    var key = event.key,
        keyCode = event.keyCode,
        altKey = event.altKey,
        ctrlKey = event.ctrlKey;
    var createIsFocused = focusedItem === _hooks.CREATE_OPTION;
    (0, _widgetHelpers.notify)(onKeyDown, [event]);
    if (event.defaultPrevented) return;

    if (key === 'ArrowDown') {
      event.preventDefault();
      if (!open) return toggle.open();
      var next = list.next(focusedItem);
      var creating = createIsFocused || showCreateOption && focusedItem === next;
      setFocusedItem(creating ? _hooks.CREATE_OPTION : next);
    } else if (key === 'ArrowUp' && (open || altKey)) {
      event.preventDefault();
      if (altKey) return toggle.close();
      setFocusedItem(createIsFocused ? list.last() : list.prev(focusedItem));
    } else if (key === 'End') {
      event.preventDefault();
      if (open) setFocusedItem(list.last());else setFocusedTag(tagList.last());
    } else if (key === 'Home') {
      event.preventDefault();
      if (open) setFocusedItem(list.first());else setFocusedTag(tagList.first());
    } else if (open && keyCode === ENTER) {
      // using keyCode to ignore enter for japanese IME
      event.preventDefault();
      if (ctrlKey && showCreateOption) return handleCreate(searchTerm, event);
      handleSelect(focusedItem, event);
    } else if (key === 'Escape') {
      if (open) toggle.close();else if (tagList) setFocusedTag(null);
    } else if (!searchTerm && !deletingRef.current) {
      if (key === 'ArrowLeft') {
        setFocusedTag(tagList.prev(focusedTag) || tagList.last());
      } else if (key === 'ArrowRight' && focusedTag) {
        var nextTag = tagList.next(focusedTag);
        setFocusedTag(nextTag === focusedTag ? null : nextTag); //
      } else if (key === 'Delete' && !tagList.isDisabled(focusedTag)) {
        handleDelete(focusedTag, event); //
      } else if (key === 'Backspace') {
        handleDelete(tagList.last(), event); //
      } else if (key === ' ' && !open) {
        event.preventDefault();
        toggle.open();
      }
    }
  }); // The EventCallback is required b/c Popup blocks updates

  var handleHoverOption = (0, _useEventCallback.default)(function (item) {
    if (!open) return;
    setFocusedItem(item);
  });
  /**
   * Methods
   */

  function change(dataItem, originalEvent, action) {
    var nextDataItems = dataItems;

    switch (action) {
      case INSERT:
        nextDataItems = nextDataItems.concat(dataItem);
        break;

      case REMOVE:
        nextDataItems = nextDataItems.filter(function (d) {
          return d !== dataItem;
        });
        break;
    }

    (0, _widgetHelpers.notify)(onChange, [nextDataItems, {
      action: action,
      dataItem: dataItem,
      originalEvent: originalEvent,
      searchTerm: searchTerm,
      lastValue: rawValue
    }]);
    clearSearch(originalEvent);
  }

  function clearSearch(originalEvent) {
    search('', originalEvent, 'clear');
  }

  function search(nextSearchTerm, originalEvent, action) {
    if (action === void 0) {
      action = 'input';
    }

    if (nextSearchTerm !== searchTerm) (0, _widgetHelpers.notify)(onSearch, [nextSearchTerm, {
      action: action,
      originalEvent: originalEvent,
      lastSearchTerm: searchTerm
    }]);
  }

  function focus() {
    var _inputRef$current2;

    (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.focus();
  }
  /**
   * Render
   */


  (0, _react.useImperativeHandle)(outerRef, function () {
    return {
      focus: focus
    };
  });
  var shouldRenderPopup = (0, _widgetHelpers.useFirstFocusedRender)(focused, open);
  var itemLabels = dataItems.map(function (item) {
    return accessors.text(item);
  });
  var shouldRenderTags = !!dataItems.length;
  var inputOwns = listId + " " + notifyId + " " + (shouldRenderTags ? tagsId : '') + (showCreateOption ? createId : '');
  return _react.default.createElement(_Widget.default, _extends({}, elementProps, {
    open: open,
    isRtl: isRtl,
    dropUp: dropUp,
    focused: focused,
    disabled: isDisabled,
    readOnly: isReadOnly,
    onKeyDown: handleKeyDown
  }, focusEvents, {
    className: (0, _classnames.default)(className, 'rw-multiselect')
  }), _react.default.createElement("span", {
    id: notifyId,
    role: "status",
    className: "rw-sr",
    "aria-live": "assertive",
    "aria-atomic": "true",
    "aria-relevant": "additions removals text"
  }, focused && (dataItems.length ? messages.selectedItems(itemLabels) : messages.noneSelected())), _react.default.createElement(_WidgetPicker.default, {
    onClick: handleClick,
    onTouchEnd: handleClick,
    onDoubleClick: handleDoubleClick,
    className: (0, _classnames.default)(containerClassName, 'rw-widget-input')
  }, _react.default.createElement(_MultiselectTagList.default, {
    id: tagsId,
    activeId: activeTagId,
    textAccessor: accessors.text,
    valueAccessor: accessors.value,
    clearTagIcon: clearTagIcon,
    label: messages.tagsLabel(),
    value: dataItems,
    readOnly: readOnly,
    disabled: disabled,
    focusedItem: focusedTag,
    onDelete: handleDelete,
    tagOptionComponent: tagOptionComponent,
    tagComponent: tagComponent,
    ref: tagsRef
  }, _react.default.createElement(_MultiselectInput.default, _extends({}, inputProps, {
    "aria-haspopup": true,
    role: "listbox",
    autoFocus: autoFocus,
    tabIndex: tabIndex || 0,
    "aria-expanded": !!open,
    "aria-busy": !!busy,
    "aria-owns": inputOwns,
    value: searchTerm,
    maxLength: maxLength,
    disabled: isDisabled,
    readOnly: isReadOnly,
    placeholder: (value.length && !showPlaceholderWithValues ? '' : placeholder) || '',
    onKeyDown: handleSearchKeyDown,
    onKeyUp: handleSearchKeyUp,
    onChange: handleInputChange,
    ref: inputRef
  }))), _react.default.createElement(_Select.default, {
    busy: busy,
    "aria-hidden": "true",
    role: "presentational",
    spinner: busySpinner,
    icon: focused ? selectIcon : null,
    disabled: isDisabled || isReadOnly
  })), shouldRenderPopup && _react.default.createElement(_Popup.default, {
    dropUp: dropUp,
    open: open,
    transition: popupTransition,
    onEntering: function onEntering() {
      return listRef.current.forceUpdate();
    }
  }, _react.default.createElement(List, _extends({}, listProps, {
    id: listId,
    data: data,
    activeId: activeOptionId,
    dataState: list.dataState,
    isDisabled: list.isDisabled,
    searchTerm: searchTerm,
    textAccessor: accessors.text,
    valueAccessor: accessors.value,
    itemComponent: itemComponent,
    groupComponent: groupComponent,
    optionComponent: optionComponent,
    focusedItem: focusedItem,
    onSelect: handleSelect,
    onMove: handleScroll,
    onHoverOption: handleHoverOption,
    "aria-live": "polite",
    "aria-labelledby": inputId,
    "aria-hidden": !open,
    ref: listRef,
    messages: {
      emptyList: lengthWithoutValues ? messages.emptyFilter : messages.emptyList
    }
  })), showCreateOption && _react.default.createElement(_AddToListOption.default, {
    id: createId,
    searchTerm: searchTerm,
    onSelect: handleCreate,
    focused: !focusedItem || focusedItem === _hooks.CREATE_OPTION
  }, messages.createOption(value, searchTerm))));
});

Multiselect.displayName = 'Multiselect';
Multiselect.propTypes = propTypes;
Multiselect.defaultProps = defaultProps;
var _default = Multiselect;
exports.default = _default;
module.exports = exports["default"];